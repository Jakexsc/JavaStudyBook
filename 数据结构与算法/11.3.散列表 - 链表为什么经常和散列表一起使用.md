### 课前问题

>  为什么散列表和链表经常会一起使用？



### LRU缓存

&emsp;如果使用单链表，我们查找一个值需要从头遍历，时间复杂度为O(n)，n等于链表的长度，加上散列表我们可以将时间复杂度降为O(1)。

![](https://i.loli.net/2020/10/10/jP4Lwo8C3N7TVGl.jpg)

&emsp;链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，hnext

&emsp;因为我们的**散列表是通过链表法解决散列冲突**的，所以**每个结点会在两条链中**。**一个链**是刚刚我们提到的**双向链表**，**另一个链是散列表中的拉链**。**前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。**

#### 如何查找一个数据

&emsp;**散列表中查找数据的时间复杂度接近 O(1)**，所以通过散列表，我们可以**很快地在缓存中找到一个数据。当找到数据之后，我们还需要将它移动到双向链表的尾部。**

#### 如何删除一个数据

&emsp;需要找到数据所在的结点，然后将结点删除。借助散列表，我们可以在 O(1) 时间复杂度里找到要删除的结点。因为**我们的链表是双向链表**，双向链表可以**通过前驱指针 O(1) 时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要 O(1) 的时间复杂度。**

#### 如何添加一个数据

&emsp;我们需要**先看这个数据是否已经在缓存中**。**如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。**



### Redis 有序集合

&emsp;**每个成员对象有两个重要的属性，key（键值）和 score（分值）**。我们不仅会通过 score 来查找数据，还会通过 key 来查找数据。

举个例子，比如用户积分排行榜有这样一个功能：**我们可以通过用户的 ID 来查找积分信息，也可以通过积分区间来查找用户 ID 或者姓名信息。这里包含 ID、姓名和积分的用户信息，就是成员对象，用户 ID 就是 key，积分就是 score。**

> **细化一下 Redis 有序集合的操作**

- 添加一个成员对象
- 按照键值来删除一个成员对象
- 按照键值来查找一个成员对象
- 按照分值区间查找数据，比如查找积分在[100, 356]之间的成员对象
- 按照分值从小到大排序成员变量

&emsp;如果我们**仅仅按照分值将成员对象组织成跳表**的结构，那**按照键值来删除、查询成员对象就会很慢**

&emsp;我们可以**再按照键值构建一个散列表，这样按照 key 来删除、查找一个成员对象的时间复杂度就变成了 O(1)**。同时，**借助跳表结构，其他操作也非常高效**

&emsp;**查找成员对象的排名（Rank）或者根据排名区间查找成员对象。这个功能单纯用刚刚讲的这种组合结构就无法高效实现了。**



### Java LinkedHashMap

&emsp;先来看一段代码

```java
HashMap<Integer, Integer> m = new LinkedHashMap<>();
m.put(3, 11);
m.put(1, 12);
m.put(5, 23);
m.put(2, 22);

for (Map.Entry e : m.entrySet()) {
  System.out.println(e.getKey());
}
```

&emsp;上面的代码会**按照数据插入的顺序依次来打印，也就是说，打印的顺序就是 3，1，5，2**。**LinkedHashMap** 也是通过**散列表和链表组合**在一起实现的。

&emsp;实际上，它**不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据**。

```java
// 10是初始大小，0.75是装载因子，true是表示按照访问时间排序
HashMap<Integer, Integer> m = new LinkedHashMap<>(10, 0.75f, true);
m.put(3, 11);
m.put(1, 12);
m.put(5, 23);
m.put(2, 22);

m.put(3, 26);
m.get(5);

for (Map.Entry e : m.entrySet()) {
  System.out.println(e.getKey());
}
```

&emsp;这段代码**打印的结果是 1，2，3，5**。

&emsp;每次**调用 put() 函数**，**往 LinkedHashMap 中添加数据的时候，都会将数据添加到链表的尾部，所以，在前四个操作完成之后，链表中的数据**是下面这样：

![](https://i.loli.net/2020/10/10/8KMVixB2WgXhcbE.jpg)

&emsp;在第 8 行代码中，**再次将键值为 3 的数据放入到 LinkedHashMap** 的时候，会**先查找这个键值是否已经有**了，然后，**再将已经存在的 (3,11) 删除，并且将新的 (3,26) 放到链表的尾部**。所以，这个时候链表中的数据就是下面这样:

![](https://i.loli.net/2020/10/10/1OqaDbPmLhtKxRj.jpg)

&emsp;当第 9 行代码**访问到 key 为 5 的数据的时候**，我们**将被访问到的数据移动到链表的尾部**。所以，第 9 行代码之后，链表中的数据是下面这样：

![](https://i.loli.net/2020/10/10/Nj1VI8ueKyqYcTo.jpg)

&emsp;最后打印出来的数据是 1，2，3，5。

&emsp;**按照访问时间排序的 LinkedHashMap 本身就是一个支持 LRU 缓存淘汰策略的缓存系统。它们两个的实现原理也是一模一样的**

&emsp;实际上，**LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。**



### 课后思考

1. 今天讲的几个散列表和链表结合使用的例子里，我们用的都是双向链表。如果把双向链表改成单链表，还能否正常工作呢？为什么呢？

   > **应该是能正常工作的，如果改用单链表，在删除一个节点时，需要拿到前一个节点的指针，那么需要重新遍历，时间复杂度变成了O(n)，效率太差了。**

   

2. 假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：

   - 根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息
   - 查找积分在某个区间的猎头 ID 列表
   - 查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表

   > **1.以积分排序构建一个跳表，再以猎头 ID 构建一个散列表**
   >
   > **2.跳表可以支持区间访问**
   >
   > **3.暂时无法实现**