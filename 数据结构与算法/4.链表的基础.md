### 学习链表有什么用呢？

1. 经典的**链表应用场景**，那就是 **LRU 缓存淘汰算法**。 缓存是一种**提高数据读取性能的技术**，在硬件设计、软件开发中都有着非常广泛的应用，比如**常见的 CPU 缓存、数据库缓存、浏览器缓存**等等
2. 缓存的大小有限，当缓存被用满时，**哪些数据应该被清理出去，哪些数据应该被保留？（** **先进先出**策略 **FIFO**（First In，First Out）、**最少使用**策略 **LFU**（Least Frequently Used）、**最近最少使用**策略 **LRU**（Least Recently Used）， 总而言之就是，**旧的，用得少的**，就**优先考虑丢弃****）**

### 带着问题学习

&emsp;**如何用链表来实现 LRU 缓存淘汰策略呢？**

### 五花八门的链表结构

#### 1.**底层的存储结构**

- 数组**需要一块连续的内存空间来存储**，对**内存的要求比较高**。如果我们**申请一个 100MB 大小的数组**，当**内存中没有连续的、足够大的存储空间**时，即便**内存的剩余总可用空间大于 100MB，仍然会申请失败**
- 链表恰恰相反，它并不需要一块连续的内存空间，它**通过“指针”将一组零散的内存块串联起来使用**，所以如果我们申请的是 100MB 大小的链表，根本不会有问题

#### 2.**单链表、双向链表和循环链表**

- **单链表**

> 链表通过指针**将一组零散的内存块串联在一起**。其中，我们把**内存块称为链表的“结点”**。为了将所有的结点串起来，每个链表的结点**除了存储数据**之外，还需要**记录链上的下一个结点的地址**。如图所示，我们把这个**记录下个结点地址的指针**叫作**后继指针 next**

![](https://ae01.alicdn.com/kf/Ud765516614564686874cda4bef54d86fA.jpg)

&emsp;**data: 结点，next：后继指针，** 我们习惯性地把**第一个结点叫作头结点**，把**最后一个结点叫作尾结点**。其中，**头结点**用来记录**链表的基地址**。有了它，我们就可以遍历得到整条链表。而**尾结点**特殊的地方是：指针不是指向下一个结点，而是**指向一个空地址 NULL**

![](https://ae01.alicdn.com/kf/U06a0de88b09949a09acdf7c4474033aea.jpg)

&emsp;链表的**插入和删除操作**，我们只需要考虑**相邻结点的指针改变**，所以对应的**时间复杂度是 O(1)，** 链表要想**随机访问第 k 个元素**，就**没有数组那么高效**了。 

&emsp;因为链表中的数据**并非连续存储**的，所以**无法像数组那样，根据首地址和下标**，通过**寻址公式**就能直接计算出对应的**内存地址**，而是**需要根据指针一个结点一个结点地依次遍历**，直到**找到相应的结点**。

- **循环链表**是一种**特殊的单链表**

> 跟**单链表**唯一的**区别就在尾结点，** 循环链表的**尾结点指针是指向链表的头结点**

![](https://ae01.alicdn.com/kf/Uee3102ad2b1c47b08902cb381ab15464f.jpg)

&emsp;要处理的数据具有**环型结构特点**时，就特别**适合采用循环链表**

- **双向链表**

> 每个结点不止有一个**后继指针 next** 指向后面的结点，还有一个**前驱指针 prev** 指向**前面的结点**

![](https://ae01.alicdn.com/kf/Ue0c426118bf24803b7134a3c564802b1P.jpg)

&emsp;**双向链表要比单链表占用更多的内存空间**， 双向链表可以**支持 O(1) 时间复杂度**的情况下**找到前驱结点**

- **单链表的插入、删除操作的时间复杂度已经是 O(1)** 了，**双向链表还能再怎么高效**呢

  **删除一个数据**无外乎这**两种情况**

  - 删除结点中“**值等于某个给定值**”的结点（ 尽管**单纯的删除操作时间复杂度是 O(1)**，但**遍历查找的时间是主要的耗时点**，对应的**时间复杂度为 O(n)**。根据时间复杂度分析中的**加法法则**，**删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)**)
  - 删除给**定指针指向的结点**。（ 我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而**单链表并不支持直接获取前驱结点**，所以，为了找到前驱结点，我们还是**要从头结点开始遍历链表**，直到 **p->next=q，说明 p 是 q 的前驱结点，** **双向链表**中的结点已经**保存了前驱结点的指针**，**不需要像单链表那样遍历，** 单链表删除操作需要 O(n) 的时间复杂度，而**双向链表只需要在 O(1) 的时间复杂度**内就搞定了）

  &emsp;对于一个**有序链表**，**双向链表的按值查询的效率也要比单链表高一些，** 我们可以**记录上次查找的位置 p**，每次**查询时，根据要查找的值与 p 的大小关系**，决定是**往前还是往后查找**，所以**平均只需要查找一半**的数据。（ **LinkedHashMap** 的实现原理，就会发现其中就**用到了双向链表**这种数据结构，**LinkedList**也是）
  
  &emsp;**对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗**

- **双向循环链表**

  ![](https://ae01.alicdn.com/kf/U79cbff2523084cceaa0629ee13558729K.jpg)

#### 3.**链表 VS 数组性能大比拼**

![](https://ae01.alicdn.com/kf/U167f4084d82d486392396a900896cd26F.jpg)

- **数组**简单易用，在实现上**使用的是连续的内存空间**，可以**借助 CPU 的缓存机制**，**预读**数组中的**数据**，所以**访问效率更高**。而**链表**在内存中并**不是连续存储**，所以**对 CPU 缓存不友好**，**没办法有效预读**
- **数组的缺点**是**大小固定**，一经声明就**要占用整块连续内存空间**。如果**声明的数组过大**，系统**可能没有足够的连续内存空间分配给它**，**导致“内存不足**（out of memory）”。如果**声明的数组过小**，则可能出现**不够用的情况**。这时只能再**申请一个更大的内存空间，把原数组拷贝进去，非常费时**。**链表**本身**没有大小的限制**，天然地**支持动态扩容**，我觉得**这也是它与数组最大的区别**
- ArrayList 动态扩容: 我们往**支持动态扩容的数组中插入一个数据**时，如果**数组中没有空闲空间**了，就会**申请一个更大的空间**，**将数据拷贝**过去，而**数据拷贝的操作是非常耗时**的

### 解答开篇

> **如何用链表来实现 LRU 缓存淘汰策略呢？**

&emsp;如果**此数据之前已经被缓存在链表中**了，我们**遍历得到这个数据对应的结点**，并**将其从原来的位置删除**，然后**再插入到链表的头部**

&emsp;如果此数据**没有在缓存链表中**，又可以分为两种情况：

> 1.如果此时**缓存未满**，则将**此结点直接插入到链表的头部**
>
> 2.如果此时**缓存已满**，则**链表尾结点删除**，将**新的数据结点插入链表的头部**

&emsp;我们可以继续**优化这个实现思路**，比如**引入散列表**（Hash table）来**记录每个数据的位置**，将**缓存访问的时间复杂度降到 O(1)**

#### 数组来实现 LRU 缓存淘汰策略

> **首位置保存最新访问数据，末尾位置优先清理**

- 如果**没有保存缓存数组里面**，直接**插入到首位置**，**后面的数据都要往后挪一位，时间复杂度为O(n)**
- 如果**在缓存数组里面**，**查找到数据并插入到首位置**，**后面的数据往后挪一位，时间复杂度为O(n)**
- 如果**缓存数组已满，删除尾部位置，不需要挪动位置，时间复杂度为O(1)**

### **课后思考**

&emsp;如何**判断一个字符串是否是回文字符串**

### [链表的仓库](https://github.com/Jakexsc/Algorithm/tree/master/src/com/xsc/linkedstudy)
