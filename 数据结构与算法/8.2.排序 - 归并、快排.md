### 课前问题

> 如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？



### [归并排序](https://github.com/Jakexsc/Algorithm/blob/master/src/com/xsc/sortstudy/MergeSort.java)

#### 1.思想

&emsp;如果要排序一个数组，我们**先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起**，这样整个数组就都有序了

![](https://i.loli.net/2020/09/18/Jt79uBRlyEa8fZC.jpg)

&emsp;归并排序使用的就是**分治思想**。分治，顾名思义，就是分而治之，**将一个大问题分解成小的子问题来解决**

&emsp;分治算法**一般都是用递归来实现**的。**分治是一种解决问题的处理思想，递归是一种编程技巧**

#### 2.递归代码来实现归并排序

&emsp;写递归代码的技巧就是，**分析得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码**，想写出归并排序的代码，我们**先写出归并排序的递推公式**

```java
merge_sort(p...r) = merge(merge_sort(p...q), merge_sort(q + 1...r));

终止条件：p >= r 不用再继续分解
```

&emsp;**merge_sort(p...r)表示给从下标p到r的数组排序，那么把这个数组分成小的问题，即下标p...q数组排序和下标q + 1...r的数组排序，q表示数组的中间位置，即(p...r) / 2。等小问题都排序好了，在把他们合并，那么p...r的数组就已经排序好了。**

#### 第一，归并排序是稳定的排序算法吗？

&emsp;**归并排序稳不稳定关键要看 merge() 函数，在合并的过程中，如果 A[p…q]和 A[q+1…r]之间有值相同的元素，那我们可以像伪代码中那样，先把 A[p…q]中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法**

#### 第二，归并排序的时间复杂度是多少？

&emsp;递归的适用场景是，一个问题 a 可以分解为多个子问题 b、c，那求解问题 a 就可以分解为求解问题 b、c。问题 b、c 解决之后，我们再把 b、c 的结果合并成 a 的结果，那么我们**定义求解a问题为T(a)，问题b、c分别为T(b)、T(c)，那么我们可以得到这条公式**

```java
T(a) = T(b) + T(c) + k
```

&emsp;**k为将问题b和问题c合并为问题a所消耗的时间**

&emsp;我们可以得到一个重要的结论：**不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式**

&emsp;假设一个归并排序是T(n)，那么把一个大问题分为两个小问题，那么**小问题的归并排序时间复杂度为T(n / 2)，把小问题合并的时间复杂度为O(n)**，那么得出递推公式为

```java
T(n) = 2 * T(n / 2) + n; n > 1
```

那么根据递推公式来分解计算过程

```java
T(n) = 2 * T(n/2) + n
     = 2 * (2 * T(n/4) + n/2) + n = 4 * T(n/4) + 2 * n
     = 4 * (2 * T(n/8) + n/4) + 2 * n = 8 * T(n/8) + 3 * n
     = 8 * (2 * T(n/16) + n/8) + 3 * n = 16 * T(n/16) + 4 * n
     ......
     = 2^k * T(n / 2^k) + k * n
     ......
```

&emsp;我们可以得到 **T(n) = 2^k * T(n / 2^k) + kn**。当 T(n/2^k)=T(1) 时，也就是 n / 2^k=1，我们得到 k=log2n 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。所以**归并排序的时间复杂度是 O(nlogn)**

&emsp;从我们的原理分析和伪代码可以看出，**归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)**

#### 第三，归并排序的空间复杂度是多少？

&emsp;**归并排序不是原地排序算法**，在**合并**两个有序数组为一个有序数组时，**需要借助额外的存储空间**，**尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)**



### [快速排序](https://github.com/Jakexsc/Algorithm/blob/master/src/com/xsc/sortstudy/QuickSort.java)

#### [第二种写法 -> for循环](https://github.com/Jakexsc/Algorithm/blob/master/src/com/xsc/sortstudy/QuickSortTwo.java)

#### [第三种写法 -> 随机基数](https://github.com/Jakexsc/Algorithm/blob/master/src/com/xsc/sortstudy/QuickSortThree.java)

#### 1.原理

&emsp;快排利用的**也是分治思想**。乍看起来，它**有点像归并排序，但是思路其实完全不一样**

#### 2.思想

&emsp;如果**要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）**

&emsp;遍历 p 到 r 之间的数据，**将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间**。经过这一步骤之后，数组 p 到 r 之间的数据就**被分成了三个部分**，**前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的**

![](https://i.loli.net/2020/09/20/sxINKC9J8Z7yqlM.jpg)

```java
递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)

终止条件：
p >= r
```

![](https://i.loli.net/2020/09/20/ILeGikRyJwv7l3F.jpg)

&emsp;因为分区的过程涉及交换操作，如果**数组中有两个相同的元素**，**比如序列 6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变**。所以，**快速排序并不是一个稳定的排序算法**

#### 快速排序的性能分析

&emsp;已经分析了稳定性和空间复杂度。**快排是一种原地、不稳定的排序算法**。现在，我们集中精力来看快排的时间复杂度

&emsp;对于递归代码的时间复杂度，**前面总结的公式，这里也还是适用的**。**如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn)**

```java
T(1) = C；   n=1时，只需要常量级的执行时间，所以表示为C。
T(n) = 2*T(n/2) + n； n>1
```

&emsp;如果数组中的数据原来已经是有序的了，比如 **1，3，5，6，8**。如果我们每次选择最后一个元素作为 pivot，那**每次分区得到的两个区间都是不均等的**。我们**需要进行大约 n 次分区操作，才能完成快排的整个过程**。每次分区我们**平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)**

&emsp;**T(n) 在大部分情况下的时间复杂度都可以做到 O(nlogn)**，只有在**极端情况下，才会退化到 O(n2)**。而且，我们也有**很多方法将这个概率降到很低**



### 归并排序和快速排序的区别

![](https://i.loli.net/2020/09/22/a8qM92CF7hUn16m.jpg)

&emsp;可以发现，**归并排序的处理过程是由下到上的，先处理子问题，然后再合并**。而**快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题**。**归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法**。我们前面讲过，**归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行**。**快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题**



### 课后解答

> [如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？-> 优先队列](https://github.com/Jakexsc/Algorithm/blob/master/src/com/xsc/leetcode/Solution19.java)
>
> [如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？-> 快速排序思想](https://github.com/Jakexsc/Algorithm/blob/master/src/com/xsc/leetcode/Solution215Two.java)

 &emsp;快排核心思想就是分治和分区，我们可以利用分区的思想，比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4

&emsp;我们选择数组区间 A[0…n-1]的最后一个元素 A[n-1]作为 pivot(这里可以优化成随机选取作为pivot)，对数组 A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1] 

&emsp;如果 p+1=K，那 A[p]就是要求解的元素；如果 K>p+1, 说明第 K 大元素出现在 A[p+1…n-1]区间，我们再按照上面的思路递归地在 A[p+1…n-1]这个区间内查找。同理，如果 K<p+1，那我们就在 A[0…p-1]区间查找

![7](https://i.loli.net/2020/09/20/IxlN1awVQiLMA76.jpg)

&emsp;时间复杂度是 O(n)

&emsp;第一次分区查找，我们需要对大小为 n 的数组执行**分区操作，需要遍历 n 个元素**。**第二次分区查找，我们只需要对大小为 n/2 的数组执行分区操作**，需要遍历 n/2 个元素。依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……**直到区间缩小为 1**

&emsp;如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1。这是一个**等比数列求和**，**最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n)**