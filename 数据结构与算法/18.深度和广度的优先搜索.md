### 课前问题

&emsp;一个用户的**一度连接用户很好理解，就是他的好友**，**二度连接用户就是他好友的好友**，**三度连接用户就是他好友的好友的好友**。在社交网络中，我们**往往通过用户之间的连接关系，来实现推荐“可能认识的人”这么一个功能**。

> 给你一个用户，如何找出这个用户的所有三度（其中包含一度、二度和三度）好友关系？



### 什么是“搜索”算法？

&emsp;**深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的**。这是因为，图这种数据结构的表达能力很强，**大部分涉及搜索的场景都可以抽象成“图”**。

&emsp;邻接表来存储图。

```java
/**
 * 无向图 -> 邻接表
 *
 * @author JakeXsc
 * @version 1.0
 * @date 2020/10/20 20:30
 */
public class Graph {
    /**
     * 顶点的数量
     */
    private int n;
    /**
     * 顶点
     */
    private LinkedList<Integer>[] adj;

    public Graph(int n) {
        this.n = n;
        adj = new LinkedList[n];
        for (int i = 0; i < n; i++) {
            adj[i] = new LinkedList<>();
        }
    }

    /**
     * 无向图添加边
     *
     * @param i 顶点
     * @param j 顶点
     */
    private void addEdge(int i, int j) {
        adj[i].add(j);
        adj[j].add(i);
    }
}
```

&emsp;深度优先搜索算法和广度优先搜索算法，既可以用在无向图，也可以用在有向图上。



### 广度优先搜索（BFS）

&emsp;**广度优先搜索**（Breadth-First-Search），我们平常都**简称 BFS**。直观地讲，它其实就是**一种“地毯式”层层推进的搜索策略**，即**先查找离起始顶点最近的，然后是次近**的，**依次往外搜索**。

![](https://i.loli.net/2020/10/20/dkXtTGIKxRY8vqh.jpg)

&emsp;visited 是**用来记录已经被访问的顶点，用来避免顶点被重复访问**。如果顶点 q 被访问，那相应的 visited[q]会被设置为 true。

&emsp;queue 是一个队列，**用来存储已经被访问、但相连的顶点还没有被访问的顶点**。因为广度优先搜索是逐层访问的，也就是说，我们只有把第 k 层的顶点都访问完成之后，才能访问第 k+1 层的顶点。当我们访问到第 k 层的顶点的时候，我们需要把第 k 层的顶点记录下来，稍后才能通过第 k 层的顶点来找第 k+1 层的顶点。所以，我们用这个队列来实现记录的功能。

&emsp;prev **用来记录搜索路径**。当我们从顶点 s 开始，广度优先搜索到顶点 t 后，prev 数组中存储的就是搜索的路径。不过，这个路径是反向存储的。prev[w]存储的是，顶点 w 是从哪个前驱顶点遍历过来的。比如，我们通过顶点 1 的邻接表访问到顶点 2，那 prev[2]就等于 1。为了正向打印出路径，我们需要递归地来打印，你可以看下 print() 函数的实现方式。

![](https://i.loli.net/2020/10/20/E6i3B4lQGj7Dpag.jpg)

![](https://i.loli.net/2020/10/20/1e76UruhMDZN3oE.jpg)

![](https://i.loli.net/2020/10/20/Ae627UnBu8DMoJR.jpg)

```java
/**
 * 广度优先搜索 -> 搜索顶点s 到 顶点t的路径
 *
 * @param s 顶点
 * @param t 顶点
 */
private void bfs(int s, int t) {
    // 如果顶点s和顶点t一致，证明值相同，直接返回
    if (s == t) {
        return;
    }
    // 如果顶点被访问设置为true，用来避免顶点被重复访问
    boolean[] visited = new boolean[n];
    // 先设置第一个访问的顶点为true
    visited[s] = true;
    // 用来存储已经被访问、但相连的顶点还没有被访问的顶点
    Queue<Integer> queue = new LinkedList<>();
    // 先添加第一个顶点
    queue.add(s);
    // 路径
    int[] prev = new int[n];
    // 先遍历路径数组，默认值为-1
    for (int i = 0; i < n; i++) {
        prev[i] = -1;
    }

    // 如果队列不为空
    while (queue.size() != 0) {
        // 取出值
        int poll = queue.poll();
        // 遍历顶点的边
        for (int i = 0; i < adj[poll].size(); i++) {
            // 先取出第一条边
            int q = adj[poll].get(i);
            // 如果它不为true
            if (visited[q] != true) {
                // 将它设置为上一个顶点
                prev[q] = poll;
                // 如果找到我们搜索最后的顶点
                if (q == t) {
                    // 打印出来
                    print(prev, s, t);
                    return;
                }
            }
            // 将它设置为访问过
            visited[q] = true;
            // 并添加到队列里面
            queue.add(q);
        }
    }
}

/**
 * 递归打印路径，从后开始递归 顶点s -> 顶点t
 *
 * @param prev 路径数组
 * @param s    第一个顶点s
 * @param t    最后的顶点t
 */
private void print(int[] prev, int s, int t) {
    // 如果不是我们开始搜索的顶点
    if (prev[t] != -1 && t != s) {
        // 继续向前递归，传入我们的这个顶点的向一个顶点
        print(prev, s, prev[t]);
    }
    // 如果是则打印
    System.out.print(t + " ");
}
```

&emsp;广度优先搜索的时间、空间复杂度是多少呢？

&emsp;最坏情况下，**终止顶点 t 离起始顶点 s 很远，需要遍历完整个图才能找到**。这个时候，**每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是 O(V+E)**，其中，**V 表示顶点的个数，E 表示边的个数**。当然，对于一个**连通图来说，也就是说一个图中的所有顶点都是连通的，E 肯定要大于等于 V-1，所以，广度优先搜索的时间复杂度也可以简写为 O(E)**

&emsp;广度优先搜索的**空间消耗主要在几个辅助变量 visited 数组、queue 队列、prev 数组上**。这三个存储空间的**大小都不会超过顶点的个数**，所以**空间复杂度是 O(V)**



### 深度优先搜索（DFS -> Depth-First-Search）

&emsp;深度优先搜索（Depth-First-Search），简称 DFS。最直观的例子就是“走迷宫”。

&emsp;假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略。

&emsp;搜索的**起始顶点是 s，终止顶点是 t**，我们希望在图中寻找一条从顶点 s 到顶点 t 的路径。如果映射到迷宫那个例子，**s 就是你起始所在的位置，t 就是出口。**

&emsp;这里面**实线箭头表示遍历，虚线箭头表示回退**。从图中我们可以看出，**深度优先搜索找出来的路径，并不是顶点 s 到顶点 t 的最短路径**。

![](https://i.loli.net/2020/10/21/jvAo6YJXb4imfWM.jpg)

&emsp;实际上，**深度优先搜索**用的是一种比较著名的算法思想，**回溯思想**。这种思想解决问题的过程，**非常适合用递归来实现。**

```java
/**
 * 深度搜索入口
 *
 * @param s 开始的顶点
 * @param t 结束的顶点
 */
private void dfs(int s, int t) {
    found = false;
    boolean[] visited = new boolean[n];
    // 路径
    int[] prev = new int[n];
    // 先遍历路径数组，默认值为-1
    for (int i = 0; i < n; i++) {
        prev[i] = -1;
    }
    recurDfs(s, t, visited, prev);
    print(prev, s, t);
}

/**
 * @param w       相邻已访问的顶点
 * @param t       结束的顶点
 * @param visited 记录已访问的顶点
 * @param prev    记录顶点路径
 */
private void recurDfs(int w, int t, boolean[] visited, int[] prev) {
    // 如果找到值
    if (found == true) {
        return;
    }
    // 设置已访问
    visited[w] = true;
    // 如果找到值
    if (w == t) {
        // 设置找到值
        found = true;
        return;
    }
    // 遍历顶点的相邻顶点
    for (int i = 0; i < adj[w].size(); i++) {
        int q = adj[w].get(i);
        // 如果还没被访问
        if (!visited[q]) {
            // 如果顶点的上一个访问顶点
            prev[q] = w;
            // 继续遍历当前的顶点
            recurDfs(q, t, visited, prev);
        }
    }
}
```

&emsp;**每条边最多会被访问两次**，一次是遍历，一次是回退。所以，**图上的深度优先搜索算法的时间复杂度是 O(E)**，**E 表示边的个数。**

&emsp;深度优先搜索算法的**消耗内存主要是 visited、prev 数组和递归调用栈**。visited、prev 数组的大小**跟顶点的个数 V 成正比**，递归调用栈的**最大深度不会超过顶点的个数**，所以**总的空间复杂度就是 O(V)**。



### 解答开篇

>给你一个用户，如何找出这个用户的所有三度（其中包含一度、二度和三度）好友关系？

&emsp;这个问题就**非常适合用图的广度优先搜索算法**来解决，因为**广度优先搜索是层层往外推进**的。

&emsp;首先，**遍历与起始顶点最近的一层顶点，也就是用户的一度好友，然后再遍历与用户距离的边数为 2 的顶点，也就是二度好友关系，以及与用户距离的边数为 3 的顶点，也就是三度好友关系**。

&emsp;**用一个数组来记录每个顶点与起始顶点的距离**，非常容易就可以找出三度好友关系。



### 课后思考

> 1. 我们通过广度优先搜索算法解决了开篇的问题，你可以思考一下，能否用深度优先搜索来解决呢？
>
>    &emsp;可以。DFS递归时传多一个离初始节点的距离值，访问节点时，距离超过3的不再继续递归
>
> 2. 学习数据结构最难的不是理解和掌握原理，而是能灵活地将各种场景和问题抽象成对应的数据结构和算法。今天的内容中提到，迷宫可以抽象成图，走迷宫可以抽象成搜索算法，你能具体讲讲，如何将迷宫抽象成一个图吗？或者换个说法，如何在计算机中存储一个迷宫？
>
>    &emsp;初始化两个顶点为迷宫起点和终点，从起点开始，遇到分叉点，为每个分支都新建一个节点，并和前一节点连接，递归每个分支直到终点