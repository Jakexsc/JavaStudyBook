### 学习之前的问题

​	为什么数组下标**不是从0**开始？从1开始它不是更符合我们的**人类思维**吗?

### 如何实现随机访问？

#### 1.什么是数组？

   >  **数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据**

   - **线性表** （线性表就是**数据排成像一条线一样**的结构。每个线性表上的数据**最多只有前和后两个方向**） 除了**数组，链表、队列、栈**等也是**线性表结构**。**非线性表（** **二叉树、堆、图**等**）**
   - **连续的内存空间和相同类型的数据（** 这两个限制也让数组的**很多操作变得非常低效**，比如要想在**数组中删除、插入一个数据**，为了**保证连续性**，就需要做**大量的数据搬移**工作。**）** 

#### 2.数组是如何实现根据下标随机访问数组元素？

```java
int[] a = new int[10]
```

![](https://ae01.alicdn.com/kf/Uc07ddfc9466b49cf87442f68a331627c2.jpg)

> 计算机给数组 **a[10]**，分配了一块连续内存空间 **1000～1039**，其中，内存块的首地址为 **base_address = 1000。** 计算机会给**每个内存单元分配一个地址**，计算机**通过地址来访问内存中的数据**。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：**a[i]_address = base_address + i \* data_type_size。**data_type_sise： **数组中每个元素的大小，** **数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。**

#### 4.**数组和链表**的区别

- **链表适合插入、删除**，**时间复杂度 O(1)**
- **数组适合查找，****数组支持随机访问**，**根据下标随机访问的时间复杂度为 O(1)**） **二分查找，时间复杂度也是 O(logn)**

#### 5.**低效**的**“插入”和“删除”**

- **插入：** 假设数组的**长度为 n**，现在，如果我们需要将一个数据**插入到数组**中的**第 k 个位置**。为了把第 k 个位置腾出来，给新来的数据，我们**需要将第 k～n 这部分的元素都顺序地往后挪一位****），**如果是插入**最后一个位置**，那么数组就不用挪动位置，那么**时间复杂度是O(1)**，如果是**插入到数组第一位**，那么所有位置**都要往后挪一位**，**最坏时间复杂度是O(n)**，因为**每个位置插入的概率**是一样的，所以**平均时间复杂度为O(n)。**

  ![](https://ae01.alicdn.com/kf/U5b2680860c0c4079acfccabfc29d775cO.jpg)

  - **改进：**如果数组中的**数据是有序**的，我们在**某个位置插入一个新的元素**时，就**必须按照刚才的方法搬移 k 之后的数据**。但是，如果数组中存储的数据并**没有任何规律**，数组**只是被当作一个存储数据的集合**。在这种情况下，如果**要将某个数据插入到第 k 个位置**，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接**将第 k 位的数据搬移到数组元素的最后**，**把新的元素直接放入第 k 个位置**

- **删除：** 如果**删除数组末尾的数据**，则**最好情况时间复杂度为 O(1)**；如果**删除开头的数据**，则**最坏情况时间复杂度为 O(n)**；**平均情况时间复杂度也为 O(n)，** 在某些特殊场景下，我们**并不一定非得追求数组中数据的连续性**。如果我们将多次**删除操作集中在一起执行，删除的效率会提高。**

  ![](https://ae01.alicdn.com/kf/Ua8b7f3b938454178a4f4b9d34a608b8a6.jpg)

  - **改进：** 数组 **a[10]**中存储了 **8 个元素**：**a，b，c，d，e，f，g，h**。现在，我们要**依次删除 a，b，c** 三个元素 为了**避免** d，e，f，g，h 这几个数据会**被搬移三次**，我们可以**先记录下已经删除的数据**。每次的**删除操作并不是真正地搬移数据**，只是**记录数据已经被删除**。当数组**没有更多空间存储数据**时，我们再**触发执行一次真正的删除操作**，这样就**大大减少了删除操作导致的数据搬移（**这就是 **JVM 标记清除垃圾回收算法的核心思想，MySQL的B+树也是这样操作****）** **很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子**

#### 6.警惕数组的访问**越界问题**

```java
int[] a = new int[3];
a[3] = 10;
java.lang.ArrayIndexOutOfBoundsException
```

#### 7.**容器能否完全替代数组？**

​	**ArrayList** 最大的优势就是**可以将很多数组操作的细节封装起来，** 它还有一个**优势**，就是**支持动态扩容**。**）**

​	数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要**重新分配一块更大的空间**，将**原来的数据复制过去**，然后再**将新的数据插入**  如果**使用 ArrayList**，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。

​	每次**存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小，** 扩容操作**涉及内存申请和数据搬移**，是**比较耗时**的， 最好在**创建 ArrayList 的时候事先指定数据大小**。

#### 8.是不是**数组就无用武之地了**呢？

- Java ArrayList **无法存储基本类型**，比如 int、long，需要封装为 Integer、Long 类，而 **Autoboxing、Unboxing 则有一定的性能消耗**，所以如果**特别关注性能，或者希望使用基本类型，就可以选用数组**
- 如果数据**大小事先已知**，并且对**数据的操作非常简单**，用不到 ArrayList 提供的大部分方法，也**可以直接使用数组**） 对于**业务开发，直接使用容器就足够了**，省时省力

​    毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是**做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器**，成为首选

#### 9.**解答开篇**

> 为什么数组下标**不是从0**开始？从1开始它不是更符合我们的**人类思维**吗？

​	从数组存储的**内存模型**上来看，“**下标”**最确切的定义应该是**“偏移（offset）”**。

​	前面也讲到，如果**用 a 来表示数组的首地址**，**a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置**。

​	但是，如果**数组从 1 开始计数**，那我们**计算数组元素 a[k]的内存地址就会变为**：**a[k]_address = base_address + (k-1)\*type_size，** 从 1 开始编号，每次随机访问数组元素都**多了一次减法运算**，对于 CPU 来说，就是**多了一次减法指令。**

### [数组的仓库](https://github.com/Jakexsc/Algorithm/tree/master/src/com/xsc/liststudy)
