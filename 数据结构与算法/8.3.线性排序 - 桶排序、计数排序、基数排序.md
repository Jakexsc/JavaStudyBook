### 课前问题

> 如何根据年龄给 100 万用户排序？

&emsp;**归并、快排都可以解决，但是最低的时间复杂度为O(nlogn)**



### 桶排序（Bucket sort）

#### 核心思想

> **桶排序**，顾名思义，会用到“桶”，核心思想是**将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的**

![](https://i.loli.net/2020/09/22/Vtc2BPUfs689XxS.jpg)

#### 桶排序的时间复杂度为什么是 O(n) 呢

&emsp;如果要排序的**数据有 n 个**，我们把它们**均匀地划分到 m 个桶内**，每个**桶里就有 k=n/m 个元素**。**每个桶内部使用快速排序，时间复杂度为 O(k * logk)**。**m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)**

#### 是不是可以替代我们之前讲的排序算法?

&emsp;否，桶排序对要排序数据的要求是非常苛刻的

&emsp;首先，**要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序**

&emsp;其次，**数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了**。在极端情况下，如果**数据都被划分到一个桶**里，那就**退化为 O(nlogn)** 的排序算法了

&emsp;桶排序比较适合**用在外部排序中**。**所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中**

&emsp;比如说我们**有 10GB 的订单数据，我们希望按订单金额**（假设金额都是正整数）进行排序，但是**我们的内存有限**，只有几百 MB，**没办法一次性把 10GB 的数据都加载到内存中**。这个时候该怎么办呢？

&emsp;我们可以**先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 10 万元。我们将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推**。每一个桶对应一个文件，并且**按照金额范围的大小顺序编号命名（00，01，02…99）**。理想的情况下，**如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序**。等所有**文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中**，那**这个文件中存储的就是按照金额从小到大排序的订单数据**了。

&emsp;订单按照**金额在 1 元到 10 万元之间并不一定是均匀分布**的 ，所以 **10GB 订单数据是无法均匀地被划分到 100 个文件中的。有可能某个金额区间的数据特别多，划分之后对应的文件就会很大，没法一次性读入内存**。

&emsp;针对这些**划分之后还是比较大的文件，我们可以继续划分，比如，订单金额在 1 元到 1000 元之间的比较多，我们就将这个区间继续划分为 10 个小区间，1 元到 100 元，101 元到 200 元，201 元到 300 元…901 元到 1000 元**。如果**划分之后，101 元到 200 元之间的订单还是太多，无法一次性读入内存，那就继续再划分**，直到所有的文件都能读入内存为止



### [计数排序](https://github.com/Jakexsc/Algorithm/blob/master/src/com/xsc/sortstudy/CountingSort.java)

> 计数排序其实是桶排序的一种特殊情况

#### 核心思想

&emsp;当**要排序的 n 个数据，所处的范围并不大**的时候，**比如最大值是 k，我们就可以把数据划分成 k 个桶**。每个**桶内的数据值都是相同的，省掉了桶内排序的时间**

&emsp;高考查分数系统，**系统会显示我们的成绩以及所在省的排名**。如果你**所在的省有 50 万考生，如何通过成绩快速排序得出名次**

&emsp;**考生的满分是 900 分，最小是 0 分**，这个数据的范围很小，**所以我们可以分成 901 个桶，对应分数从 0 分到 900 分**。根据考生的成绩，**我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生**，所以**并不需要再进行排序**。我们**只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序**。因为**只涉及扫描遍历操作，所以时间复杂度是 O(n)**



#### 为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？

&emsp;还拿考生那个例子来解释。为了方便说明，我对数据规模做了简化。假设**只有 8 个考生，分数在 0 到 5 分之间**。这 **8 个考生的成绩我们放在一个数组 A[8]中**，它们分别是：**2，5，3，0，2，3，0，3**

**&emsp;考生的成绩从 0 到 5 分**，我们**使用大小为 6 的数组 C[6]表示桶**，其中**下标对应分数**。不过，**C[6]内存储的并不是考生，而是对应的考生个数**，刚刚举的那个例子，我们**只需要遍历一遍考生分数，就可以得到 C[6]的值**

![](https://i.loli.net/2020/09/22/K3AQfebmVvDL8CT.jpg)

&emsp;**分数为 3 分的考生有 3 个，小于 3 分的考生有 4 个，所以，成绩为 3 分的考生在排序之后的有序数组 R[8]中，会保存下标 4，5，6 的位置**

![](https://i.loli.net/2020/09/22/aelTc4uf86IWQn3.jpg)

&emsp;我们如何快速计算出，每个分数的考生在有序数组中对应的存储位置呢？

&emsp;思路是这样的：**我们对 C[6]数组顺序求和，C[6]存储的数据就变成了下面这样子。C[k]里存储小于等于分数 k 的考生个数**

![](https://i.loli.net/2020/09/22/3rhsmqRgnCjJySU.jpg)

&emsp;C[6]=[2,0,2,3,0,1] 顺序求和后： C[6]=[2,2,4,7,7,8]

&emsp;我们从**后到前依次扫描**数组 A（因为这样使得原数组里在后的元素，在排序后的数组也放在后边），**当扫描到 3** 时，我们可以**从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3]要减 1，变成 6**

&emsp;以此类推，**当我们扫描到第 2 个分数为 3 的考生的时候，就会把它放入数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）**。当我们**扫描完整个数组 A** 后，**数组 R 内的数据就是按照分数从小到大有序排列的**了

![](https://i.loli.net/2020/09/22/edalq76rGjn3SDb.jpg)

&emsp;计数排序**只能用在数据范围不大的场景**中，如果**数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了**。而且，**计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数**

&emsp;如果考生成绩**精确到小数后一位**，我们就**需要将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内**。再比如，**如果要排序的数据中有负数，数据的范围是[-1000, 1000]，那我们就需要先对每个数据都加 1000，转化成非负整数**



### 基数排序

#### 学习问题

> 假设我们**有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法**呢

&emsp;假设要比较两个手机号码 a，b 的大小，如果**在前面几位中，a 手机号码已经比 b 手机号码大**了，那**后面的几位就不用看了**

&emsp;**借助稳定排序算法，这里有一个巧妙的实现思路，先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了**

![](https://i.loli.net/2020/09/22/Azan9kHpeDVZTjS.jpg)

&emsp;这里**按照每位来排序的排序算法要是稳定**的，否则这个实现思路就是不正确的。因为**如果是非稳定排序算法，那最后一次排序只会考虑最高位的大小顺序**，完全不管其他位的大小关系，那么**低位的排序就完全没有意义**了

&emsp;**根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)**

&emsp;有时候要排序的数据并不都是等长的，比如我们排序牛津字典中的 20 万个英文单词，最短的只有 1 个字母，最长的我特意去查了下，有 45 个字母，中文翻译是尘肺病。对于这种不等长的数据，基数排序还适用吗？

**我们可以把所有的单词补齐到相同长度，位数不够的可以在后面补**“**0**”，因为**根据ASCII 值**，**所有字母都大于**“**0**”，所以补“0”**不会影响到原有的大小顺序**。这样**就可以继续用基数排序**了

#### 总结

&emsp;**基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系**，如果 **a 数据的高位比 b 数据大，那剩下的低位就不用比较了**。除此之外，**每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n)** 了



### 课后解答

> 如何根据年龄给 100 万用户排序？

&emsp;**我们假设年龄的范围最小 1 岁，最大不超过 120 岁**。我们可以**遍历这 100 万用户，根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素**



### 课后思考

&emsp;假设我们现在需要对 **D，a，F，B，c，A，z 这个字符串进行排序**，要求**将其中所有小写字母都排在大写字母的前面**，但**小写字母内部和大写字母内部不要求有序**。比如**经过排序之后为 a，c，z，D，F，B，A**，这个如何来实现呢？**如果字符串中存储的不仅有大小写字母，还有数字**。要**将小写字母的放到前面，大写字母放在最后，数字放在中间，不用排序算法**，又该怎么解决呢？

#### 思路

##### 第一题

> 将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序

&emsp;先有两个指针，一个向前，一个向后。如果向后指针遇到大写字母则停住，如果向前指针遇到小写字母则停住。然后交换位置，如果指针碰撞则表示交换完成了，那么排序成功

##### 第二题

> 如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放到前面，大写字母放在最后，数字放在中间，不用排序算法

&emsp;分为小写分区和非小写分区，然后非小写分区再按第一题那么交换。