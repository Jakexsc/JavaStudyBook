### 最经典最常用的排序

&emsp;冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序

![](https://ae01.alicdn.com/kf/U9fd7a33edb654cf19fa2fdd8ea085658T.jpg)



### 课前问题

**&emsp;插入排序和冒泡排序**的时间复杂度相同，**都是 O(n2)**，在实际的软件开发里，**为什么我们更倾向于使用插入排序算法而不是冒泡排序算法**呢



### 如何分析一个排序算法

&emsp;分析一个排序算法，要从哪几个方面入手

#### 排序算法的执行效率

1. 最好情况、最坏情况、平均情况时间复杂度

   &emsp;分别给出最好情况、最坏情况、平均情况下的时间复杂度

   &emsp;为什么要区分这三种时间复杂度呢？**第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分**。**第二，对于要排序的数据，有的接近有序，有的完全无序**。**有序度不同的数据**，对于**排序的执行时间肯定是有影响的**，我们**要知道排序算法在不同数据下的性能表现**

2. 时间复杂度的系数、常数 、低阶

   &emsp;我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，**在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来**

3. 比较次数和交换（或移动）次数

   &emsp;基于比较的排序算法的执行过程，会涉及**两种操作**，**一种是元素比较大小，另一种是元素交换或移动**。所以，如果我们在**分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去**

#### 排序算法的内存消耗

&emsp;针对排序算法的空间复杂度，我们还**引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法**

#### 排序算法的稳定性

&emsp;针对排序算法，我们还有**一个重要的度量指标，稳定性**。这个概念是说，**如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变**

&emsp;比如说，我们现在**要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额**。如果我们现在有 10 万条订单数据，我们**希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序**。对于这样一个排序需求，我们怎么来做呢

&emsp;**我们先按照金额对订单数据进行排序**，然后，**再遍历排序之后的订单数据**，对于**每个金额相同的小区间再按照下单时间排序**。这种排序思路理解起来不难，但是**实现起来会很复杂**

&emsp;借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：**我们先按照下单时间给订单排序**，注意是按照下单时间，不是金额。排序完成之后，我们**用稳定排序算法，按照订单金额重新排序**。两遍排序之后，我们**得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的**

**&emsp;稳定排序算法可以保持金额相同的两个对象**，在排序之后的前后顺序不变。**第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序**

![](https://ae01.alicdn.com/kf/U952381531f1d4842be577e0b658b845av.jpg)



### [冒泡排序](https://github.com/Jakexsc/Algorithm/blob/master/src/com/xsc/sortstudy/BubbleSort.java)

&emsp;看下冒泡排序的整个过程。我们要对一组数据 4，5，6，3，2，1，从小到大进行排序。第一次冒泡操作的详细过程就是这样

![](https://ae01.alicdn.com/kf/Udf84d87965cc4bedbc29d86140212fb0k.jpg)

&emsp;经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了

![](https://ae01.alicdn.com/kf/U02161cdecad44ba29901758792dfc456p.jpg)

&emsp;**当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作**。我这里还有另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了

![](https://ae01.alicdn.com/kf/U08900417566c4f849b5bd201e51ecc2bt.jpg)

```java
// 冒泡排序，a表示数组，n表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) { //i表示需要冒泡操作的次数，如果数据是完全无序的，则需要n次操作
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) { //-i表示，去掉排序好的元素；-1表示跟下一个元素对比，所以不能走到最头上。
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}
```

#### 第一，冒泡排序是原地排序算法吗？

&emsp;冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。

#### 第二，冒泡排序是稳定的排序算法吗？

&emsp;当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法

#### 第三，冒泡排序的时间复杂度是多少？

**&emsp;最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作**，就可以结束了，所以**最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。**

&emsp;**平均情况下的时间复杂**是多少呢？前面讲过，**平均时间复杂度就是加权平均期望时间复杂度，分析的时候要结合概率论的知识**

&emsp;这里还有一种思路，**通过“有序度”和“逆序度”这两个概念**来进行分析

&emsp;**有序度是数组中具有有序关系的元素对的个数**。有序元素对用数学表达式表示

```java
有序元素对：a[i] <= a[j], 如果i < j
```

![a1ef4cc1999d6bd0af08d8417ee55220.jpg](https://i.loli.net/2020/09/18/HUGWuCoIvYw8OV5.jpg)

&emsp;比如 1，2，3，4，5，6，**有序度就是 n*(n-1)/2，也就是 15**。我们把这种**完全有序的数组的有序度叫作满有序度**

&emsp;逆序度的定义正好跟有序度相反（默认从小到大为有序）还可以得到一个公式：**逆序度 = 满有序度 - 有序度**

&emsp;冒泡排序**包含两个操作原子，比较和交换。每交换一次，有序度就加 1** 不管算法怎么改进，**交换次数总是确定**的，即为逆序度，也就是n*(n-1)/2–初始有序度。此例中就是 **15–3=12，要进行 12 次交换操作**。

&emsp;对于**包含 n 个数据的数组进行冒泡排序，最坏情况下，初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况**。换句话说，**平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)**。



### [插入排序](https://github.com/Jakexsc/Algorithm/blob/master/src/com/xsc/sortstudy/InsertSort.java)

![](https://i.loli.net/2020/09/18/1YQWpOMd54Ssz78.jpg)

&emsp;这是一个动态排序的过程，即**动态地往有序集合中添加数据**，我们可以通过这种方法**保持集合中的数据一直有序**。而**对于一组静态数据，我们也可以借鉴上面讲的插入方法，来进行排序**，于是就有了插入排序算法

&emsp;**插入排序具体是如何借助上面的思想来实现排序**

&emsp;我们将数组中的**数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序**。重复这个过程，直到未排序区间中元素为空，算法结束

&emsp;如图所示，要排序的数据是 4，5，6，1，3，2，其中**左侧为已排序区间，右侧是未排序区间**

![](https://i.loli.net/2020/09/18/68oNvUwlAnJXFG4.jpg)

&emsp;插入排序也**包含两种操作，一种是元素的比较，一种是元素的移动**。当我们需要**将一个数据 a 插入到已排序区间**时，**需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置**。找到插入点之后，我们**还需要将插入点之后的元素顺序往后移动一位**，这样才能腾出位置给元素 a 插入

&emsp;对于不同的查找插入点方法（从头到尾、从尾到头），**元素的比较次数是有区别**的。但**对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度**

![](https://i.loli.net/2020/09/18/OzXfpZ1E7m2agw5.jpg)

#### 第一，插入排序是原地排序算法吗？

&emsp;插入排序算法的运行**并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法**

#### 第二，插入排序是稳定的排序算法吗？

&emsp;对于值相同的元素，我们可以**选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法**

#### 第三，插入排序的时间复杂度是多少？

&emsp;要排序的数据**已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)**。注意，**这里是从尾到头遍历已经有序的数据**

&emsp;**如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n2)**

在**数组中插入一个数据的平均时间复杂度是O(n)**,对于插入排序来说，**每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n^2)**



### [选择排序](https://github.com/Jakexsc/Algorithm/blob/master/src/com/xsc/sortstudy/SelectSort.java)

&emsp;选择排序算法的**实现思路有点类似插入排序**，也分已排序区间和未排序区间。但是**选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾**

![](https://i.loli.net/2020/09/18/5nfk63AtUBZ2L7w.jpg)

#### 第一，选择排序是原地排序算法吗?

&emsp;是，它需要一个临时的常量来保存值。空间复杂度为O(1)

#### 第二，选择排序是稳定的排序算法吗？

&emsp;不是，每次选择它都是找剩余的最小值，并和前面的值交换位置，破坏了稳定性

#### 第三，插入排序的时间复杂度是多少？

&emsp;最好、最坏、平均复杂度都是O(n^2)，因为就算排好序，它还是得从头开始进行对比，寻找最小的值。



### 课后解答

> **为什么我们更倾向于使用插入排序算法而不是冒泡排序算法**

&emsp;冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。

&emsp;但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，**冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个**



