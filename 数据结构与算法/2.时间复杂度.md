### 大O表示法

>  大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是**表示代码执行时间随数据规模增长的变化趋势**，所以，也叫作**渐进时间复杂度**（asymptotic time complexity），简称**时间复杂度**。
>
>  T(n) = O(2n^2+2n+3). 在此公式中, 低阶是 2n , 常量是 3 , 系数是2. 这三部分都不会左右增长趋势,所以可以忽略， 我们只需要记录一个最大量级就可以了，所以它的时间复杂度是O(n^2)

### 时间复杂度分析

#### 1.只关注循环执行次数最多的一段代码

> 我们在分析一个算法、一段代码的时间复杂度的时候，也只关注**循环执行次数最多的那一段代码**就可以了

#### 2.**加法法则：总复杂度等于量级最大的那段代码的复杂度**

```java
int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p < 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q < n; ++q) {
     sum_2 = sum_2 + q;
   }
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
   return sum_1 + sum_2 + sum_3;
}
```

> ***例如:这段的时间复杂度为O(n^2)***

#### 3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积(** 我们可以把乘法法则看成是**嵌套循环**)

```java
int cal(int n) {
   int ret = 0;
   int i = 1;
   for (; i < n; ++i) {
     ret = ret + f(i);
   }
}

int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;
  }
  return sum;
}
```

> ***4～6 行的时间复杂度是O(n)，12~14行的时间复杂度是O(n)，在第5行调用f()，那么整个代码的时间复杂度则是T(n)=T1(n)*T(n)=O(n)*O(n)=O(n^2)***

### 几种常见时间复杂度实例分析

![](https://ae01.alicdn.com/kf/U0af23a25562c4697b806a20ee12155375.jpg)

> 我们可以粗略地分为两类，**多项式量级**和**非多项式量级**。其中，非多项式量级只有两个：**O(2n)** 和 **O(n!)**

#### 1.O(1)

```java
int i = 8;
int j = 6;
int sum = i + j;
```
> 一般情况下，只要算法中**不存在循环语句、递归语句**，即使有成千上万行的代码，其**时间复杂度也是Ο(1)**。

#### 2.O(logn)、O(nlogn)

```java
i=1;
while (i <= n)  {
   i = i * 2;
}
```

> 我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2x=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。**x=log2n**，所以，这段代码的时间复杂度就是 **O(log2n)**

#### 3.O(m+n)、O(m*n)

```java
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }


  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }


  return sum_1 + sum_2;
}
```

> m 和 n 是表示两个数据规模, 省略掉其中一个。所以，上面代码的时间复杂度就是 **O(m+n)**。 针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：**T1(m) + T2(n) = O(f(m) + g(n))**。但是乘法法则继续有效：**T1(m)\*T2(n) = O(f(m) \* f(n))**。

**从低阶到高阶有：**O(1)、O(logn)、O(n)、O(nlogn)、O(n2 ),**越高阶复杂度的算法，执行效率越低**

![](https://ae01.alicdn.com/kf/Ua9a3e72686b2499fb0f63e601a9c7b72N.jpg)

> **复杂度分析并不难，关键在于多练**

### 四个复杂度分析方面

1. **最好情况时间复杂度(** 在最理想的情况下，执行这段代码的时间复杂度**)**
2. **最坏情况时间复杂度(** 在最糟糕的情况下，执行这段代码的时间复杂度**)**
3. **平均时间复杂度(** 将各种情况发生的概率考虑进去, 实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况, 只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分**)**
4. **均摊时间复杂度**