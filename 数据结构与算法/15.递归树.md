### 课前问题

> 借助递归树来分析递归算法的时间复杂度



### 递归树与时间复杂度分析

&emsp;如果我们**把这个一层一层的分解过程画成图，它其实就是一棵树**。我们给这棵树起一个名字，叫作**递归树**。

&emsp;斐波那契数列的递归树。**一个节点的求解可以分解为左右子节点两个问题**的求解

![](https://i.loli.net/2020/10/15/kIVGigdshbC3Twn.jpg)

&emsp;归并排序每次会将数据规模一分为二。我们把归并排序画成递归树，就是下面这个样子：

![](https://i.loli.net/2020/10/15/cjNwJBxaXmoL36y.jpg)

&emsp;从图中我们可以看出，每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关。我们把每一层归并操作消耗的时间记作 n。

&emsp;我们只需要知道这棵树的高度 h，用高度 h 乘以每一层的时间消耗 n，就可以得到总的时间复杂度 O(n∗h)。

&emsp;从归并排序的原理和递归树，可以看出来，**归并排序递归树是一棵满二叉树**。

&emsp;**满二叉树的高度大约是 log2n，所以，归并排序递归实现的时间复杂度就是 O(nlogn)。**



### 实战一：分析快速排序的时间复杂度

&emsp;快速排序在**最好情况下，每次分区都能一分为二**，这个时候用**递推公式 T(n)=2T(2n)+n**，很容易就能推导出**时间复杂度是 O(nlogn)**。但是，我们**并不可能每次分区都这么幸运**，正好一分为二。

&emsp;我们假设平均情况下，**每次分区之后，两个分区的大小比例为 1:k**。当 k=9 时，如果**用递推公式的方法来求解时间复杂度的话，递推公式就写成 T(n)=T(n / 10)+T(9n / 10)+n。**

&emsp;那我们来看看，**用递归树来分析快速排序的平均情况时间复杂度**。还是取 k 等于 9，也就是说，**每次分区都很不平均，一个分区是另一个分区的 9 倍**。如果我们**把递归分解的过程画成递归树**，就是下面这个样子：

![](https://i.loli.net/2020/10/17/ELoFlXp8w6qZAks.jpg)

&emsp;每一层分区操作**所遍历的数据的个数之和就是 n**。我们现在**只要求出递归树的高度 h**，这个**快排过程遍历的数据个数就是 h∗n** ，也就是说，**时间复杂度就是 O(h∗n)**

&emsp;因为每次分区**并不是均匀地一分为二，所以递归树并不是满二叉树**。这样一个递归树的高度是多少呢？

&emsp;快速排序**结束的条件就是待排序的小区间，大小为 1**，也就是说**叶子节点里的数据规模是 1**。从**根节点 n 到叶子节点 1，递归树中最短的一个路径每次都乘以 1/10，最长的一个路径每次都乘以 9/10**。

![](https://i.loli.net/2020/10/17/EhtfC986mAYRwU5.jpg)

&emsp;遍历数据的个数总和就介于 nlog10n 和 nlog10/9 n 之间。根据复杂度的大 O 表示法，对数复杂度的底数不管是多少，我们统一写成 logn，所以，**当分区大小比例是 1:9 时，快速排序的时间复杂度仍然是 O(nlogn)**



### 实战二：分析斐波那契数列的时间复杂度

```java
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
```

![](https://i.loli.net/2020/10/17/d6BuPqZ7z4lpxsK.jpg)

&emsp;f(n) 分解为 f(n−1) 和 f(n−2)，每次数据规模都是 −1 或者 −2，叶子节点的数据规模是 1 或者 2。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 −1，那最长路径大约就是 n；如果每次都是 −2，那最短路径大约就是 n/2。

&emsp;每次分**解之后的合并操作只需要一次加法运算**，我们把这次**加法运算的时间消耗记作 1**。所以，**从上往下，第一层的总时间消耗是 1，第二层的总时间消耗是 2，第三层的总时间消耗就是 2^2**。依次类推，第 k 层的时间消耗就是 2^k−1，那**整个算法的总的时间消耗就是每一层时间消耗之和**。

&emsp;如果路径长度都为 n，那这个总和就是 2n−1

![](https://i.loli.net/2020/10/17/cdrZlIyoTJ1KEv7.jpg)

&emsp;如果路径长度都是 2^n ，那整个算法的总的时间消耗就是 2^n/2−1

![](https://i.loli.net/2020/10/17/34bohWzavqCfiVK.jpg)

&emsp;这个算法的时间复杂度就**介于 O(2^n) 和 O(2^n/2) 之间**



### 实战三：分析全排列的时间复杂度

&emsp;“**如何把 n 个数据的所有排列都找出来**”，这就是**全排列**的问题。

&emsp;比如，1，2，3 这样 3 个数据，有下面这几种不同的排列：

```java
1, 2, 3
1, 3, 2
2, 1, 3
2, 3, 1
3, 1, 2
3, 2, 1
```

&emsp;如果我们**确定了最后一位数据，那就变成了求解剩下 n−1 个数据的排列问题**。而**最后一位数据可以是 n 个数据中的任意一个**，因此它的**取值就有 n 种情况**。所以，“**n 个数据的排列”问题，就可以分解成 n 个“n−1 个数据的排列”的子问题。**

&emsp;我们把它写成递推公式，就是下面这个样子：

```java
假设数组中存储的是1，2， 3...n。
        
f(1,2,...n) = {最后一位是1, f(n-1)} + {最后一位是2, f(n-1)} +...+{最后一位是n, f(n-1)}。
```

&emsp;JAVA代码：

```java
// 调用方式：
// int[]a = a={1, 2, 3, 4}; printPermutations(a, 4, 4);
// k表示要处理的子数组的数据个数
public void printPermutations(int[] data, int n, int k) {
  if (k == 1) {
    for (int i = 0; i < n; ++i) {
      System.out.print(data[i] + " ");
    }
    System.out.println();
  }

  for (int i = 0; i < k; ++i) {
    int tmp = data[i];
    data[i] = data[k-1];
    data[k-1] = tmp;

    printPermutations(data, n, k - 1);

    tmp = data[i];
    data[i] = data[k-1];
    data[k-1] = tmp;
  }
}
```

&emsp;如何借助递归树，轻松分析出这个代码的时间复杂度。首先，我们还是画出递归树。不过，**现在的递归树已经不是标准的二叉树了。**

![](https://i.loli.net/2020/10/17/njiXCRT8posSQPO.jpg)

&emsp;第一层分解有 n 次交换操作，第二层有 n 个节点，每个节点分解需要 n−1 次交换，所以第二层总的交换次数是 n∗(n−1)。

&emsp;第三层有 n∗(n−1) 个节点，每个节点分解需要 n−2 次交换，所以第三层总的交换次数是 n∗(n−1)∗(n−2)。以此类推，第 k 层总的交换次数就是 n∗(n−1)∗(n−2)∗…∗(n−k+1)。

&emsp;最后一层的交换次数就是 n∗(n−1)∗(n−2)∗…∗2∗1。每一层的交换次数之和就是总的交换次数。

```java
n + n*(n-1) + n*(n-1)*(n-2) +... + n*(n-1)*(n-2)*...*2*1
```

&emsp;这个公式的求和比较复杂，我们看最后一个数，**n∗(n−1)∗(n−2)∗…∗2∗1 等于 n!**，而前面的 **n−1 个数都小于最后一个数，所以，总和肯定小于 n∗n!**，也就是说，**全排列的递归算法的时间复杂度大于 O(n!)，小于 O(n∗n!)**



### 课后思考

&emsp;1 个细胞的生命周期是 3 小时，1 小时分裂一次。求 n 小时后，容器内有多少细胞？请你用已经学过的递归时间复杂度的分析方法，分析一下这个递归问题的时间复杂度。