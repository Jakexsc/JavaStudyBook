### 课前问题

> 既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？



### [二叉查找树（Binary Search Tree）]((https://github.com/Jakexsc/Algorithm/blob/master/src/com/xsc/treestudy/BinarySearchTree.java))

&emsp;二叉查找树是为了实现快速查找而生的。它不仅仅**支持快速查找一个数据，还支持快速插入、删除一个数据**。

&emsp;**二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。**

![](https://i.loli.net/2020/10/12/uNGV9bXQalS3v2p.jpg)

#### 1. 二叉查找树的查找操作

&emsp;我们**先取根节点**，如果它**等于我们要查找的数据，那就返回**。如果要**查找的数据比根节点的值小，那就在左子树中递归查找**；如果要**查找的数据比根节点的值大，那就在右子树中递归查找**。

![](https://i.loli.net/2020/10/12/ZNizCwSockAnsqm.jpg)

```java
/**
 * 二叉查找树
 *
 * @author JakeXsc
 * @version 1.0
 * @date 2020/10/12 16:16
 */
public class BinarySearchTree {
    private TreeNode treeNode;

    /**
     * @param value 要找的值
     * @return TreeNode -> 找到的节点
     */
    private TreeNode findValue(int value) {
        // 记录根节点
        TreeNode p = treeNode;
        // 如果节点不为空
        while (p != null) {
            // 如果查找的值比节点小，从左节点找
            if (value < p.val) {
                p = p.left;
                // 如果查找的值比节点小，从左节点找
            } else if (value > p.val) {
                p = p.right;
                // 如果查找的值与节点相等，直接返回
            } else {
                return p;
            }
        }
        return null;
    }

    static class TreeNode {
        private int val;
        private TreeNode left;
        private TreeNode right;

        public TreeNode(int val) {
            this.val = val;
        }
    }
}
```

#### 2. 二叉查找树的插入操作

&emsp;新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系

&emsp;如果要**插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置**；如果**不为空，就再递归遍历右子树，查找插入位置**。同理，**如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置**。

![](https://i.loli.net/2020/10/12/d3qDYc2xXakghlT.jpg)

```java
/**
 * 插入操作
 *
 * @param value 插入的值
 */
private void insertValue(int value) {
    // 如果树为空，那么插入的值作为根节点
    if (treeNode == null) {
        treeNode = new TreeNode(value);
        return;
    }
    TreeNode p = treeNode;
    // 如果存在树
    while (p != null) {
        // 比根节点大，那么插入右树为空的位置上，如果不为空，一直找
        if (value > p.val) {
            if (p.right == null) {
                p.right = new TreeNode(value);
                return;
            }
            p = p.right;
            // 比根节点小，那么插入左树为空的位置上，如果不为空，一直找
        } else {
            if (p.left == null) {
                p.left = new TreeNode(value);
                return;
            }
            p = p.left;
        }
    }

}
```

#### 3. 二叉查找树的删除操作

&emsp;针对要删除节点的子节点个数的不同，我们需要**分三种情况来处理**。

&emsp;第一种情况是，如果**要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null**。比如图中的删除节点 55。

&emsp;第二种情况是，**如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点**就可以了。比如图中的删除节点 13。

&emsp;第三种情况是，**如果要删除的节点有两个子节点。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点**，因为**最小节点肯定没有左子节点**（如果有左子结点，那就不是最小节点了），所以，我们**可以应用上面两条规则来删除这个最小节点**。比如图中的删除节点 18。

![](https://i.loli.net/2020/10/12/xJ9OIskbdfaWDVj.jpg)

```java
/**
 * 删除操作
 *
 * @param value 删除的值
 */
private void deleteNode(int value) {
    // 记录当前节点，初始化为根节点
    TreeNode p = treeNode;
    // 记录父节点
    TreeNode pp = null;
    // 寻找要删除的值
    while (p != null && p.val != value) {
        pp = p;
        if (value > p.val) {
            p = p.right;
        } else {
            p = p.left;
        }
    }
    // 没找到直接返回
    if (p == null) {
        return;
    }

    // 如果要删除的节点存在左节点和右节点，从右树寻找最小值来替换
    if (p.left != null && p.right != null) {
        /// 记录p
        TreeNode minP = p.right;
        // p的父节点
        TreeNode minPP = p;
        while (minP.left != null) {
            minPP = minP;
            minP = minP.left;
        }
        // 把值替换
        p.val = minP.val;
        // 更新当前节点
        p = minP;
        // 更新父节点
        pp = minPP;
    }

    // 记录子节点
    TreeNode child;
    //如果它存在左节点或右节点
    if (p.left != null) {
        child = p.left;
    } else if (p.right != null) {
        child = p.right;
        // 不存在子节点
    } else {
        child = null;
    }

    // 删除的是根节点
    if (pp == null) {
        treeNode = child;
        // 指向父节点指向它的子节点，如果它不存在子节点，那么直接删除
    } else if (pp.left == p) {
        pp.left = child;
    } else {
        pp.right = child;
    }

}
```

&emsp;关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是**单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉**。这样原本**删除的节点还需要存储在内存中，比较浪费内存空间**，但是删除操作就变得简单了很多。而且，**这种处理方法也并没有增加插入、查找操作代码实现的难度。**



#### 4. 二叉查找树的其他操作

&emsp;除了插入、删除、查找操作之外，二叉查找树中**还可以支持快速地查找最大节点和最小节点、前驱节点和后继节点。**

&emsp;二叉查找树除了支持上面几个操作之外，**还有一个重要的特性，就是中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。**因此，**二叉查找树也叫作二叉排序树**。



### 支持重复数据的二叉查找树

&emsp;很多时候，在实际的软件开发中，我们**在二叉查找树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值（key）来构建二叉查找树**。我们**把对象中的其他字段叫作卫星数据**。

&emsp;如果存储的两个对象键值相同，有两种解决方法。

&emsp;第一种方法比较容易。二叉查找树中**每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。**（哈希冲突的解决方法）

&emsp;第二种方法。**每个节点仍然只存储一个数据**。在查找插入位置的过程中，**如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。**

![](https://i.loli.net/2020/10/14/d4zl1K3oEkiALTa.jpg)

&emsp;当要查找数据的时候，**遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。**这样就可以把键值等于要查找值的所有节点都找出来。

![](https://i.loli.net/2020/10/14/4GFhebsvYpMBH6t.jpg)

&emsp;对于删除操作，我们也**需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。**



### 二叉查找树的时间复杂度分析

&emsp;二叉查找树的形态各式各样。比如这个图中，对于同一组数据，我们构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。**图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。**

![](https://i.loli.net/2020/10/14/1SUOfk2jBh9bQi5.jpg)

&emsp;不管操作是插入、删除还是查找，**时间复杂度其实都跟树的高度成正比，也就是 O(height)。**既然这样，现在问题就转变成另外一个了，也就是，**如何求一棵包含 n 个节点的完全二叉树的高度？**

&emsp;**树的高度就等于最大层数减一**，从图中可以看出，包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，**第 K 层包含的节点个数就是 2^(K-1)。**

&emsp;对于完全二叉树来说，**最后一层的节点个数有点儿不遵守上面的规律了**。**它包含的节点个数在 1 个到 2^(L-1) 个之间**（我们假设最大层数是 L）。**如果我们把每一层的节点个数加起来就是总的节点个数 n**。也就是说，如果节点的个数是 n，那么 n 满足这样一个关系：

```java
n >= 1+2+4+8+...+2^(L-2)+1
n <= 1+2+4+8+...+2^(L-2)+2^(L-1)
```

&emsp;借助**等比数列的求和公式**，我们可以计算出，**L 的范围是[log2(n+1), log2n +1]**。完全二叉树的层数小于等于 log2n +1，也就是说，**完全二叉树的高度小于等于 log2n**

&emsp;**极度不平衡的二叉查找树，它的查找性能肯定不能满足我们的需求**。我们需要构建一种不管怎么删除、插入数据，在任何时候，**都能保持任意节点左右子树都比较平衡的二叉查找树**，**一种特殊的二叉查找树，平衡二叉查找树。平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。解答开篇**



### 解答开篇

>既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？

有下面几个原因：

1.  第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。

2. 第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。

3. 第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。

4. 第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。

&emsp;最后，**为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表**，不然会浪费一定的存储空间。

&emsp;综合这几点，**平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择使用哪一个。**



### 课后思考

> 今天我讲了二叉树高度的理论分析方法，给出了粗略的数量级。如何通过编程，求出一棵给定二叉树的确切高度呢？

&emsp;确定二叉树高度有两种思路：**第一种是深度优先思想的递归，分别求左右子树的高度。当前节点的高度就是左右子树中较大的那个+1**；第二种可以采用**层次遍历**的方式，每一层记录都记录下当前队列的长度，这个是队尾，每一层队头从0开始。然后每遍历一个元素，队头下标+1。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层刚开始遍历的时候，树的高度+1。最后队列为空，就能得到树的高度。