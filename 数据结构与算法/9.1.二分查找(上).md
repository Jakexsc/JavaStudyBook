### 课前思考

> 假设我们有 1000 万个整数数据，每个数据占 8 个字节，**如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？**



### 二分思想

&emsp;二分查找是一种非常简单易懂的快速查找算法，比如说，我们现在来做一个**猜字游戏**。我随机写一个 0 到 99 之间的数字，然后你来猜我写的是什么。猜的过程中，**你每猜一次，我就会告诉你猜的大了还是小了，直到猜中为止**。

&emsp;假设我写的数字是 23（如果猜测范围的数字有偶数个，中间数有两个，就选择较小的那个。）

![](https://i.loli.net/2020/10/03/5mlyWhwYErXQaJs.jpg)

> ***这个例子用的就是二分思想***

&emsp;假设**有 1000 条订单数据，已经按照订单金额从小到大排序，每个订单金额都不同**，并且**最小单位是元**。我们现在想知道**是否存在金额等于 19 元的订单**。如果**存在，则返回订单数据，如果不存在则返回 null**。

&emsp;**最简单的办法**当然是**从第一个订单开始，一个一个遍历这 1000 个订单，直到找到金额等于 19 元的订单为止**。但这样查找会比较慢，用二分查找能不能更快速地解决呢？

&emsp;我们**假设只有 10 个订单**，订单金额分别是：8，11，19，23，27，33，45，55，67，98。还是**利用二分思想，每次都与区间的中间数据比对大小，缩小查找区间的范围**。

![](https://i.loli.net/2020/10/03/KhE1AawDNLFXWzS.jpg)

&emsp;**二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。**



### O(logn) 惊人的查找速度

&emsp;二分查找是一种**非常高效的查找算法**，我们**假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。**

![](https://i.loli.net/2020/10/03/cQ6H1os7DgBOkXA.jpg)

&emsp;这是一个**等比数列。其中 n/2^k=1 时，k 的值就是总共缩小的次数。**而每一次缩小操作只涉及两个数据的大小比较，所以，**经过了 k 次区间缩小操作，时间复杂度就是 O(k)。通过 n/2^k=1，我们可以求得 k=log2n，所以时间复杂度就是 O(logn)**。

&emsp;O(logn) 这种对数时间复杂度。**这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级 O(1) 的算法还要高效**。因为 logn 是一个非常“恐怖”的数量级，即便 n 非常非常大，对应的 logn 也很小。比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。

&emsp;用**大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶**。对于常量级时间复杂度的算法来说，**O(1) 有可能表示的是一个非常大的常量值，比如 O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高**



### 二分查找的递归与非递归实现

&emsp;**最简单的情况就是有序数组中不存在重复元素**，我们在其中用二分查找值等于给定值的数据。

- ***[非递归实现](https://github.com/Jakexsc/Algorithm/blob/master/src/com/xsc/searchstudy/BinarySearch.java)***

  ```java
  /**
   * @param arr   查找的数组
   * @param n     数组长度
   * @param value 查找的值
   * @return int -> 值的下标
   */
  private static int bSearch(int[] arr, int n, int value) {
      // 左边指针
      int low = 0;
      // 右边指针
      int high = n - 1;
      // TODO 注意这里的条件是low <= high
      while (low <= high) {
          // 中间值下标
          int mid = low + (high - low) / 2;
          // 如果中间值刚好是我们要的值
          if (arr[mid] == value) {
              // 返回中间值下标
              return mid;
              // 如果中间值小于我们要的值，证明值在右边区域
          } else if (arr[mid] < value) {
              low = mid + 1;
              // 如果中间值大于我们要的值，证明值在左边区域
          } else {
              high = mid - 1;
          }
      }
      // 没有我们要的值，直接返回-1;
      return -1;
  }
  ```

  &emsp;low、high、mid 都是指数组下标，其中 low 和 high 表示当前查找的区间范围，初始 low=0， high=n-1。mid 表示[low, high]的中间位置。我们通过对比 a[mid]与 value 的大小，来更新接下来要查找的区间范围，直到找到或者区间缩小为 0，就退出。

  &emsp;**就着重强调一下容易出错的 3 个地方**

  1. **循环退出条件**

     &emsp;注意是 low<=high，而不是 low

  2. **mid 的取值**

     &emsp;实际上，**mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出**。**改进的方法是将 mid 的计算方式写成 low+(high-low)/2**。更进一步，如果**要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)>>1)**。因为相比除法运算来说，**计算机处理位运算要快得多**

  3. low 和 high 的更新

     &emsp;**low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环**。比如，当 **high=3，low=3 时，如果 a[3]不等于 value，就会导致一直循环不退出。**

     

- ***[递归实现](https://github.com/Jakexsc/Algorithm/blob/master/src/com/xsc/searchstudy/InternallyBinarySearch.java)***

  ```java
  /**
   * 查找入口
   *
   * @param arr   查找的数组
   * @param n     数组的长度
   * @param value 查找的值
   * @return int -> 值的下标
   */
  private static int binarySearch(int[] arr, int n, int value) {
      return internallyBinarySearch(arr, 0, n - 1, value);
  }
  
  /**
   * 递归方法
   *
   * @param arr   查找的数组
   * @param low   最左边的下标
   * @param high  最右边的下标
   * @param value 查找的值
   * @return int -> 值的下标
   */
  private static int internallyBinarySearch(int[] arr, int low, int high, int value) {
      // 递归终止条件，如果最左边的下标大于最右边的下标
      if (low > high) {
          return -1;
      }
  
      // 中间值
      int mid = low + (high - low) / 2;
      // 如果中间值等于要查找的值
      if (arr[mid] == value) {
          // 返回中间值下标
          return mid;
          // 如果中间值小于我们要的值，证明值在右边区域
      } else if (arr[mid] < value) {
          return internallyBinarySearch(arr, mid + 1, high, value);
          // 如果中间值大于我们要的值，证明值在左边区域
      } else {
          return internallyBinarySearch(arr, low, mid - 1, value);
      }
  }
  ```



### 二分查找应用场景的局限性

&emsp;**二分查找的时间复杂度是 O(logn)，查找数据的效率非常高**。不过，并不是什么情况下都可以用二分查找，**它的应用场景是有很大局限性的。**

#### 1. 首先，二分查找依赖的是顺序表结构，简单点说就是数组。

&emsp;那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是**二分查找算法需要按照下标随机访问元素**。**数组**按照下标**随机访问**数据的**时间复杂度是 O(1)**，而**链表随机访问的时间复杂度是 O(n)**。所以，如果**数据使用链表存储，二分查找的时间复杂就会变得很高**

&emsp;***二分查找只能用在数据是通过顺序表来存储的数据结构上。***

#### 2. 其次，二分查找针对的是有序数据

&emsp;二分查找对这一点的要求比较苛刻，**数据必须是有序的。如果数据没有序，我们需要先排序**。排序的时间复杂度最低是 O(nlogn)。**如果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。**

&emsp;但是，**如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。**针对这种**动态数据集合，无论哪种方法，维护有序的成本都是很高的。**

&emsp;**二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。**针对动态数据集合，如何在其中快速查找某个数据呢？**二叉树**

#### 3. 再次，数据量太小不适合二分查找。

&emsp;如果要处理的**数据量很小，完全没有必要用二分查找，顺序遍历就足够了**。只有**数据量比较大**的时候，**二分查找的优势才会比较明显。**

如果**数据之间的比较操作非常耗时**，不管数据量大小，都**推荐使用二分查找**。比如，**数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。**

#### 4. 最后，数据量太大也不适合二分查找。

&emsp;二分查找的**底层需要依赖数组这种数据结构**，而**数组为了支持随机访问的特性，要求内存空间连续**，对内存的要求比较苛刻。比如，**我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。**

&emsp;即便**有 2GB 的内存空间剩余**，但是**如果这剩余的 2GB 内存空间都是零散的**，**没有连续的 1GB 大小的内存空间**，那照样**无法申请一个 1GB 大小的数组。**



### 课后解答

> 假设我们有 1000 万个整数数据，每个数据占 8 个字节，**如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？**

&emsp;我们的**内存限制是 100MB，每个数据大小是 8 字节，最简单的办法就是将数据存储在数组中**，内存占用差不多是 80MB，符合内存的限制。我们**可以先对这 1000 万数据从小到大排序，然后再利用二分查找算法，就可以快速地查找想要的数据了**。

&emsp;**散列表、二叉树这些支持快速查找的动态数据结构**。你可能会觉得，用散列表和二叉树**也可以解决这个问题。实际上是不行的。**

&emsp;**不管是散列表还是二叉树，都会需要比较多的额外的内存空间**。如果用散列表或者二叉树来存储这 1000 万的数据，用 100MB 的内存肯定是存不下的。而**二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式**，所以刚好能在限定的内存大小下解决这个问题



### 课后思考

1. 如何编程**实现“求一个数的平方根”？要求精确到小数点后 6 位。**

2. 如果**数据使用链表存储**，二分查找的时间复杂就会变得很高，那**查找的时间复杂度究竟是多少**？

   &emsp;时间复杂度为

   ```java
   f(n) = n + n/2 + n/4 + n/8 ...... + 1 = O(n)
   ```

   &emsp;而为什么**不推荐使用链表实现二分查找，因为链表需要移动指针**。每次查找都要从头慢慢移动指针到中间位置，重复如此，直到找到中间值。所以不推荐。**链表随机访问的时间复杂度为O(n)。**