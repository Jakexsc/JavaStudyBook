### 课前问题

&emsp;推荐注册返佣金的这个功能我想你应该不陌生吧？现在很多 App 都有这个功能。这个功能中，**用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”**

&emsp;一般来说，**我们会通过数据库来记录这种推荐关系**。在数据库表中，**我们可以记录两行数据，其中 actor_id 表示用户 id，referrer_id 表示推荐人 id**

&emsp; **定一个用户 ID，如何查找这个用户的“最终推荐人”？**



### 如何理解“递归”？

#### 有两个最难理解的知识点

1. 一个是动态规划
2. 另一个就是递归

&emsp;很多**数据结构和算法的编码实现都要用到递归**，**比如 DFS 深度优先搜索、前中后序二叉树遍历**等等

&emsp;**去的过程叫**“***递***”，**回来的过程**叫“***归***”。基本上，所有的**递归问题都可以用递推公式**来表示
$$
f(n)=f(n-1)+1，f(1)=1
$$
&emsp;f(1)=1 表示第一排的人知道自己在第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码

```java
int f(int n) {
  if (n == 1) return 1;
  return f(n-1) + 1;
}
```



### 递归需要满足的三个条件

#### 1. 一个问题的解可以分解为几个子问题的解

&emsp;**何为子问题？子问题就是数据规模更小的问题**。比如，前面讲的电影院的例子，你要知道，“**自己在哪一排**”的问题，可以**分解为**“**前一排的人在哪一排**”这样一个子问题

#### 2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样

&emsp;你**求解“自己在哪一排”的思路**，和**前面一排人求解“自己在哪一排”的思路**，**是一模一样的**

#### 3.存在递归终止条件

&emsp;**把问题分解为子问题**，把**子问题再分解为子子问题**，一层一层分解下去，**不能存在无限循环**，这就**需要有终止条件**

&emsp;**第一排的人不需要再继续询问任何人**，就知道自己在哪一排，也就是 f(1)=1，这就是**递归的终止条件**



### 如何编写递归代码？

&emsp;写递归代码**最关键的是写出递推公式，找到终止条件**

&emsp;假如这里有 n 个台阶，每次你**可以跨 1 个台阶或者 2 个台阶**，请问**走这 n 个台阶有多少种走法**？如果有 **7 个台阶**，你可以 **2，2，2，1 这样子上去**，也**可以 1，2，1，1，2 这样子上去**，总之走法有很多，那如何**用编程求得总共有多少种走法**呢？

&emsp;我们仔细想下，实际上，可以**根据第一步的走法把所有走法分为两类**，第**一类是第一步走了 1 个台阶**，另**一类是第一步走了 2 个台阶**。所以 **n 个台阶的走法就等于先走 1 阶后**，**n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法**。用**公式表示**就是
$$
f(n) = f(n-1)+f(n-2)
$$
&emsp;再来**看下终止条件**。当**有一个台阶**时，我们**不需要再继续递归**，就只有一种走法。所以 f(1)=1。这个**递归终止条件足够吗**？我们**可以用 n=2，n=3 这样比较小的数试验一下**

&emsp;**n=2 时，f(2)=f(1)+f(0)**。**如果递归终止条件只有一个 f(1)=1，那 f(2) 就无法求解了**。所以**除了 f(1)=1** 这一个递归终止条件外，**还要有 f(0)=1**，表示**走 0 个台阶有一种走法**，不过**这样子看起来就不符合正常的逻辑思维**了。所以，**我们可以把 f(2)=2 作为一种终止条件**，表示**走 2 个台阶**，有**两种走法**，**一步走完或者分两步来走**

&emsp;**我们把递归终止条件和刚刚得到的递推公式放到一起**就是这样的

```java
f(1) = 1;
f(2) = 2;
f(n) = f(n-1)+f(n-2)
```

&emsp;有了这个公式，我们转化成递归代码就简单多了。**最终的递归代码**是这样的

```java
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
```

&emsp;总结一下，**写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码**

&emsp;**只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可**，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。**屏蔽掉递归细节，这样子理解起来就简单多**了

&emsp;因此，**编写递归代码的关键**是，只要遇到递归，我们**就把它抽象成一个递推公式**，不用想一层层的调用关系，**不要试图用人脑去分解递归的每个步骤**



### 递归代码要警惕堆栈溢出

&emsp;在实际的软件开发中，编写递归代码时，我们会遇到很多问题，比如**堆栈溢出**。而**堆栈溢出会造成系统性崩溃**，后果会非常严重。**为什么递归代码容易造成堆栈溢出**呢？我们**又该如何预防堆栈溢出**呢？

&emsp;系统栈或者虚拟机栈空间一般都不大。**如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险**

&emsp;可以通过在代码中**限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错**

```java
// 全局变量，表示递归的深度。
int depth = 0;

int f(int n) {
  ++depth；
  if (depth > 1000) throw exception;
  
  if (n == 1) return 1;
  return f(n-1) + 1;
}
```

&emsp;但这种做法并不能完全解决问题，因为**最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算**。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，**如果最大深度比较小，比如 10、50，就可以用这种方法**，否则这种方法并不是很实用



### 递归代码要警惕重复计算

&emsp;如果我们把整个递归过程分解一下的话，那就是这样的

![](https://ae01.alicdn.com/kf/Udedace99fc9642a080884c7c1be74fccW.jpg)

&emsp;从图中，我们可以直观地看到，想要**计算 f(5)，需要先计算 f(4) 和 f(3)**，而**计算 f(4) 还需要计算 f(3)**，因此，**f(3) 就被计算了很多次，这就是重复计算问题**

&emsp;为了避免重复计算，我们可以**通过一个数据结构（比如散列表）来保存已经求解过的 f(k)**。当**递归调用到 f(k) 时，先看下是否已经求解过了**。如果**是**，则直接**从散列表中取值返回**，不需要重复计算，这样就能避免刚讲的问题了

```java
public int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  // hasSolvedList可以理解成一个Map，key是n，value是f(n)
  if (hasSolvedList.containsKey(n)) {
    return hasSolvedList.get(n);
  }
  
  int ret = f(n-1) + f(n-2);
  hasSolvedList.put(n, ret);
  return ret;
}
```

&emsp;在**时间效率**上，递归代码里**多了很多函数调用**，当**这些函数调用的数量较大**时，就会**积聚成一个可观的时间成本**。在**空间复杂度**上，因为**递归调用一次就会在内存栈中保存一次现场数据**，所以在**分析递归代码空间复杂度时，需要额外考虑这部分的开销**，比如我们前面讲到的**电影院递归代码**，空间复杂度并**不是 O(1)**，而**是 O(n)**



### 怎么将递归代码改写为非递归代码？

&emsp;递归有利有弊，**利是递归代码的表达力很强，写起来非常简洁**；而**弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题**。所以，在开发过程中，我们要**根据实际情况来选择**是否需要用递归的方式来实现

&emsp;看 f(x) =f(x-1)+1 这个递推公式。我们这样改写看看

```java
int f(int n) {
  int ret = 1;
  for (int i = 2; i <= n; ++i) {
    ret = ret + 1;
  }
  return ret;
}
```

&emsp;第二个例子也可以改为非递归的实现方式

```java
int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  int ret = 0;
  int pre = 2;
  int prepre = 1;
  for (int i = 3; i <= n; ++i) {
    ret = pre + prepre;
    prepre = pre;
    pre = ret;
  }
  return ret;
}
```

&emsp;是不是所有的递归代码都可以改为这种**迭代循环的非递归写法**呢？

&emsp;是的。因为**递归本身就是借助栈来实现**的，只不过我们**使用的栈是系统或者虚拟机本身提供的**，我们没有感知罢了。**如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子**。

&emsp;**但是这种思路实际上是将递归改为了“手动”递归，本质并没有变**，而且也并**没有解决前面讲到的某些问题，徒增了实现的复杂度**。



### 课后解答

> 如何找到“最终推荐人”？

```java
long findRootReferrerId(long actorId) {
  Long referrerId = select referrer_id from [table] where actor_id = actorId;
  if (referrerId == null) return actorId;
  return findRootReferrerId(referrerId);
}
```

&emsp;第一，如果递归很深，可能会有堆栈溢出的问题。(限制递归深度)

&emsp;第二，如果数据库里存在脏数据，我们还需要**处理由此产生的无限递归问题**。比如 demo 环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果 **A 的推荐人是 B，B 的推荐人是 C，C 的推荐人是 A，这样就会发生死循环**。(检测递归是否存在环)



### 课后思考

&emsp;我们平时调试代码喜欢使用 IDE 的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，有什么好的调试方法呢

1. 打印日志发现，递归值。
2. 结合条件断点进行调试。