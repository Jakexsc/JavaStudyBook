### 课前问题

> 如何存储用户密码这么重要的数据吗？仅仅 MD5 加密一下存储就够了吗？在实际的开发中，我们该如何用哈希算法解决问题。



### 什么是哈希算法？

&emsp;**将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值**

设计一个优秀的哈希算法，需要满足的几点要求:

- **从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）**
- **对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同**
- **散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小**
- **哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值**

> 拿 MD5 这种哈希算法来具体说明一下

&emsp;分别对“今天我来讲哈希算法”和“jiajia”这两个文本，计算 MD5 哈希值，得到两串看起来毫无规律的字符串（**MD5 的哈希值是 128 位的 Bit 长度**，为了方便表示，我把它们转化成了 16 进制编码），无论**哈希的文本有多长、多短，通过 MD5 哈希之后，得到的哈希值的长度都是相同的，而且得到的哈希值看起来像一堆随机数，完全没有规律**。

```java
MD5("今天我来讲哈希算法") = bb4767201ad42c74e650c1b6c03d78fa
MD5("jiajia") = cd611a31ea969b908932d44d126d195b
```

```java
MD5("我今天讲哈希算法！") = 425f0d5a917188d2c3c3dc85b5e4f2cb
MD5("我今天讲哈希算法") = a1fb91ac128e6aa37fe42c663971ac3d
```

&emsp;比如上面的例子中，我们就很难通过哈希值“a1fb91ac128e6aa37fe42c663971ac3d”反推出对应的文本“我今天讲哈希算法”。

&emsp;哈希算法要处理的文本可能是各种各样的。比如，对于非常长的文本，如果哈希算法的计算时间很长，那就只能停留在理论研究的层面，很难应用到实际的软件开发中。



### 哈希算法常见4大应用

#### 应用一：安全加密

&emsp;最常用于加密的哈希算法是 **MD5**（MD5 Message-Digest Algorithm，**MD5 消息摘要**算法）和 **SHA**（Secure Hash Algorithm，**安全散列**算法）。

&emsp;还有很多其他加密算法，比如 **DES**（Data Encryption Standard，**数据加密**标准）、**AES**（Advanced Encryption Standard，**高级加密**标准）。

&emsp;用于加密的哈希算法来说，有**两点格外重要**。第一点是**很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。**

&emsp;第一点很好理解，**加密的目的就是防止原始数据泄露**，所以很难通过哈希值反向推导原始数据，这是一个**最基本的要求**。着重第二点。实际上，**不管是什么哈希算法，我们只能尽量减少碰撞冲突的概率，理论上是没办法做到完全不冲突的。**

&emsp;基于组合数学中一个非常基础的理论，**鸽巢原理**

&emsp;我们知道，**哈希算法产生的哈希值的长度是固定且有限的**。比如前面举的 MD5 的例子，**哈希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，而我们要哈希的数据是无穷的**。基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况。这里你应该能想到，**一般情况下，哈希值越长的哈希算法，散列冲突的概率越低**

```java
2^128=340282366920938463463374607431768211456
```

&emsp;这两段字符串经过 MD5 哈希算法加密之后，产生的哈希值是相同的。

![](https://i.loli.net/2020/10/10/nGYmqDQslFubOwg.jpg)

![](https://i.loli.net/2020/10/10/sXyOvwbpk4mQCV5.jpg)

&emsp;即便哈希算法**存在散列冲突**的情况，但是**因为哈希值的范围很大，冲突的概率极低，所以相对来说还是很难破解的**。像 MD5，**有 2^128 个不同的哈希值，这个数据已经是一个天文数字了，所以散列冲突的概率要小于 1/2^128**。

&emsp;MD5 哈希值，希望通过毫无规律的穷举的方法，**找到跟这个 MD5 值相同的另一个数据，那耗费的时间应该是个天文数字**。所以，**即便哈希算法存在冲突，但是在有限的时间和资源下，哈希算法还是很难被破解的**。

&emsp;**没有绝对安全的加密。越复杂、越难破解的加密算法，需要的计算时间也越长。**比如 SHA-256 比 SHA-1 要更复杂、更安全，相应的计算时间就会比较长。我们在**实际的开发过程**中，也**需要权衡破解难度和计算时间，来决定究竟使用哪种加密算法。**

#### 应用二：唯一标识

&emsp;如果要**在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息（比如图片名称）来比对**，因为有可能**存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。**

&emsp;**任何文件在计算中都可以表示成二进制码串**，所以，比较笨的办法就是，**拿要查找的图片的二进制码串与图库中所有图片的二进制码串一一比对**。如果**相同，则说明图片在图库中存在**。但是，**每个图片小则几十 KB、大则几 MB，转化成二进制是一个非常长的串，比对起来非常耗时。**

&emsp;可以**给每一个图片取一个唯一标识，或者说信息摘要。**比如，我们**可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识。**

&emsp;还想继续提高效率，我们可以**把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中**。当要**查看某个图片**是不是在图库中的时候，我们**先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识**。

&emsp;如果**不存在**，那就**说明这个图片不在图库中**；如果**存在**，我们**再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样**。

&emsp;如果**一样，就说明已经存在；如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片**。

#### 应用三：数据校验

&emsp;**BT 下载的原理是基于 P2P 协议的**。我们**从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块**（比如**可以分成 100 块，每块大约 20MB**）。**等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了**

&emsp;**网络传输是不安全的，**下载的文件块有可能是被宿主机器恶意修改过的，又或者下载过程中出现了错误，所以下载的文件块可能不是完整的。如果我们没有能力检测这种恶意修改或者文件下载出错，就会导致最终合并后的电影无法观看，甚至导致电脑中毒。

&emsp;通过哈希算法，**对 100 个文件块分别取哈希值**，并且**保存在种子文件中**。所以，**当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块**

#### 应用四：散列函数

&emsp;**散列函数是设计一个散列表的关键**。它**直接决定了散列冲突的概率和散列表的性能**。相对哈希算法的其他应用，**散列函数对于散列算法冲突的要求要低很多**。即便**出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。**

**&emsp;散列函数对于散列算法计算得到的值**，是否**能反向解密也并不关心**。散列函数中用到的散列算法，**更加关注散列后的值是否能平均分布（是否能均匀地散列在各个槽中）**。散列函数执行的快慢，也会影响散列表的性能，所以，**散列函数用的散列算法一般都比较简单，比较追求效率。**



### 课后解答

>如何存储用户密码这么重要的数据吗？仅仅 MD5 加密一下存储就够了吗？在实际的开发中，我们该如何用哈希算法解决问题。

&emsp;可以通过哈希算法，对**用户密码进行加密之后再存储**，最好使用**SHA**（MD5已经被破解）

&emsp;如果用户信息被“脱库”，黑客虽然拿到是加密之后的密文，但可以**通过“猜”的方式来破解密码**（字典攻击），这是因为，有些用户的密码太简单。比如很多人习惯用 00000、123456 这样的简单数字组合做密码，很容易就被猜中。

&emsp;**需要维护一个常用密码的字典表，把字典中的每个密码用哈希算法计算哈希值**，然后**拿哈希值跟脱库后的密文比对**。**如果相同**，**基本上**就可以认为，这个**加密之后的密码对应的明文就是字典中的这个密码**。

&emsp;针对字典攻击，我们可以引入一个**盐**（salt），**跟用户的密码组合在一起，增加密码的复杂度。我们拿组合之后的字符串来做哈希算法加密，将它存储到数据库中**，进一步增加破解的难度。**安全和攻击是一种博弈关系，不存在绝对的安全。所有的安全措施，只是增加攻击的成本而已。**



### 课后思考

> 能讲一讲**区块链使用的是哪种哈希算法**吗？是**为了解决什么**问题而使用的呢？

&emsp;区块头保存着 **自己区块体** 和 **上一个区块头 的哈希值**。

&emsp;因为这种**链式关系和哈希值的唯一性**，只要区块链上**任意一个区块被修改过，后面所有区块保存的哈希值就不对**了。

&emsp;区块链**使用的是 SHA256 哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。**

