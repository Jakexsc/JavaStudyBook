### 课前问题

> **world文档的拼写检查功能是如何实现的?**



### 散列思想

&emsp;散列表一般指“哈希表”或“hash表”。散列表**用的是数组支持按照下标随机访问数据的特性**，所以**散列表其实就是数组的一种扩展，由数组演化而来**。可以说，如果**没有数组，就没有散列表**。简单来说，就是**通过hash函数计算hash值，然后与数组的容量求余得到下标，然后存放到数组中。**

&emsp;比如，我们用6位数来表示参赛编号。051167，其中，前两位 05 表示年级，中间两位 11 表示班级，最后两位还是原来的编号 1 到 89。

&emsp;尽管我们不能直接把编号作为数组下标，但我们**可以截取参赛编号的后两位作为数组下标，来存取选手信息数据。当通过参赛编号查询选手信息的时候，我们用同样的方法，取参赛编号的后两位，作为数组下标，来读取数组中的数据**

&emsp;这就是典型的散列思想。其中，**参赛选手的编号我们叫做键**（key）或者关键字。我们用它来标识一个选手。我们把**参赛编号转化为数组下标的映射方法就叫作散列函数**（或“Hash 函数”“哈希函数”），而**散列函数计算得到的值就叫作散列值**（或“Hash 值”“哈希值”）。

![](https://i.loli.net/2020/10/08/vGKfEVWhpitkJP5.jpg)

&emsp;我们可以总结出这样的规律：**散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。**



### 散列函数

&emsp;它**是一个函数**。我们可以把它定义成 hash(key)，**其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。**

```java
private static int hash(String key) {
  // 获取后两位字符
  string lastTwoChars = key.substr(key.length()-2, key.length());
  // 将后两位字符转换为整数
  int hashValue = Integer.valueOf(lastTwoChars);
  return hashValue;
}
```

&emsp;但是，如果参赛选手的**编号是随机生成的 6 位数字，又或者用的是 a 到 z 之间的字符串，该如何构造散列函数呢？我总结了三点散列函数设计的基本要求：**

1. 散列函数计算得到的**散列值是一个非负整数**
2. 如果 **key1 = key2，那 hash(key1) == hash(key2)**
3. 如果 **key1 ≠ key2，那 hash(key1) ≠ hash(key2)**

&emsp;第三点：**要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的**。哈希冲突无法完全避免，因为**数组的存储空间有限，也会加大散列冲突的概率**。

&emsp;所以我们**几乎无法找到一个完美的无冲突的散列函数**，即便能找到，**付出的时间成本、计算成本也是很大**的，所以**针对散列冲突问题，我们需要通过其他途径来解决**。



### 哈希冲突

&emsp;我们常用的散列冲突解决方法有两类，**开放寻址法**（open addressing）和**链表法**（chaining）

#### **开放寻址法**

如果出现了散列冲突，我们就**重新探测一个空闲位置，将其插入**。

##### **线性探测**

&emsp;当我们**往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。**

&emsp;这里面**黄色的色块表示空闲位置，橙色的色块表示已经存储了数据**。

![](https://i.loli.net/2020/10/08/Hg1UGKYnhbdPMze.jpg)

&emsp;散列表的**大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了**，所以就产生了冲突。**于是我们就顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置 2**，于是**将其插入到这个位置**。

&emsp;在散列表中**查找元素的过程有点儿类似插入过程**。我们**通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素**。如果**相等，则说明就是我们要找的元素**；**否则就顺序往后依次查找**。如果**遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中**。

![](https://i.loli.net/2020/10/08/lHvBu2c1M9T4P8C.jpg)

&emsp;散列表跟数组一样，**不仅支持插入、查找操作，还支持删除操作**，删除操作稍微有些特别。**我们不能单纯地把要删除的元素设置为空**

&emsp;比如050306，我们将06作为数组的下标，即arr[6]，那么如果我们将arr[1]这个位置设置为null来表示删除，如果我们查找arr[6]，它碰到arr[1]==null，它就会认为这是个空闲位置，根据线性探测的方法，即表示arr[6]这个hash值在散列表中不存在，所以我们如果要删除，只能设置arr[1]做一个delete标记，让它继续往下找。

![](https://i.loli.net/2020/10/08/VpCOlmIwHk17M6N.jpg)

&emsp;那么可以看出，如果**散列表插入越多，那么空闲位置只会越来越少**，线性探测的时间就会越长。**极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据**

&emsp;另外两种比较经典的探测方法，**二次探测**（Quadratic probing）和**双重散列**（Double hashing）

##### 二次探测

&emsp;**跟线性探测很像，线性探测每次探测的步长是 1**，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……**而二次探测探测的步长就变成了原来的“二次方”**，也就是说，**它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……**

##### 双重散列

&emsp;**就是不仅要使用一个散列函数**。我们**使用一组散列函数** hash1(key)，hash2(key)，hash3(key)……我们**先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置**

&emsp;**不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高**。为了尽可能保证散列表的操作效率，一般情况下，**我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。**

```
散列表的装载因子=填入表中的元素个数/散列表的长度
```

&emsp;**装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。**



#### 链表法

&emsp;**链表法**是一种**更加常用的散列冲突解决办法**，相比开放寻址法，它要**简单**很多。在散列表中，**每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。*

![](https://i.loli.net/2020/10/08/CoKhRdB9F6DOQ4L.jpg)

&emsp;**当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。**

&emsp;**删除、插入这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。**



### 解答开篇

> **world文档的拼写检查功能是如何实现的?**

&emsp;常用的英文单词是20万个单词，假设一个单词长度是10，那么平均一个单词的字节是10kb，那么20W个单词差不多就2MB的存储空间。我们那么将这20W个单词存入到散列表中，当用户输入单词，那么我们就去这个散列表查，如果查不到，证明这个单词可能是拼写错误。



### 课后思考

1. 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？

   &emsp;可以将10万条访问日志存入散列表，其中key为URL，value初始值为0。 当第一条URL存入散列表，再有相同的URL存入会产生散列冲突。此时，再比较key是否相同。如果key相同，则是同一个URL，将相应的value++；如果key不相同，则存入链表下一个位置。 可以在外部将最大值K给记录下来。插入完成以后，就可以取得当前URL的出现次数的范围即0-K。 根据K的大小选取相应的算法。如果K值不大，可以采用桶排序。如果K值很大，可采用快排。 为什么使用散列表进行存储： 散列表存储完成以后，已经对URL完成了去重操作，同时拿到了最大次数K，根据K选择合适的排序算法。 时间复杂度分析： 10万条URL存入散列表，时间复杂度为O(n)。 桶排序，时间复杂度为O(n)。 快排，时间复杂度为O(nlogn)。

    

2. 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？

   &emsp;以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)