### 课前问题

> RK 算法是如何借助哈希算法来实现高效字符串匹配的呢



### [BF 算法](https://github.com/Jakexsc/Algorithm/blob/master/src/com/xsc/stringsearch/BfSearch.java)

&emsp;BF 算法中的 BF 是 Brute Force 的缩写，中文叫作**暴力匹配算法，也叫朴素匹配算法**。

#### 两个概念(主串和模式串)。

&emsp;我们在字符串 A 中查找字符串 B，那字符串 A 就是主串，字符串 B 就是模式串。我们把主串的长度记作 n，模式串的长度记作 m。因为我们是在主串中查找模式串，所以 n>m。

&emsp;BF 算法的思想可以用一句话来概括，那就是，我**们在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的。**

![](https://i.loli.net/2020/10/21/eofxsOK13nhJSPL.jpg)

&emsp;在极端情况下，比如主串是“aaaaa…aaaaaa”（省略号表示有很多重复的字符 a），模式串是“aaaaab”。我们每次都比对 m 个字符，要比对 n-m+1 次，所以，**这种算法的最坏情况时间复杂度是 O(n*m)**。

&emsp;在实际的开发中，它却是一个比较常用的字符串匹配算法。原因有两点。

&emsp;第一，实际的软件开发中，大部分情况下，**模式串和主串的长度都不会太长**。而且每次模式串与主串中的子串匹配的时候，当**中途遇到不能匹配的字符的时候，就可以就停止**了，不需要把 m 个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是 O(n*m)，但是，统计意义上，大部分情况下，**算法执行效率要比这个高很多**。

&emsp;第二，**朴素字符串匹配算法思想简单，代码实现也非常简单**。简单意味着不容易出错，如果**有 bug 也容易暴露和修复**。在工程中，在**满足性能要求的前提下，简单是首选**。



### RK 算法

&emsp;RK 算法的全称叫 Rabin-Karp 算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的。它其实就是刚刚讲的 BF 算法的升级版。

#### 思路

&emsp;我们**通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小**。如果**某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了**（这里先不考虑哈希冲突的问题）。因为**哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高**了。

![](https://i.loli.net/2020/10/21/Bl6tE19Ky2nGqso.jpg)

&emsp;通过哈希算法计算子串的哈希值的时候，我们**需要遍历子串中的每个字符**。尽管**模式串与子串比较的效率提高**了，但是，**算法整体的效率并没有提高**。

&emsp;这就需要哈希算法设计的非常有技巧了。我们**假设要匹配的字符串的字符集中只包含 K 个字符**，我们可以**用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值**。

&emsp;比如要处理的字符串只包含 a～z 这 26 个小写字母，那我们就**用二十六进制来表示一个字符串**。我们**把 a～z 这 26 个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推**，z 表示 25

![](https://i.loli.net/2020/10/21/Swdop5VTWJMyrHN.jpg)

&emsp;假设字符串中只包含 a～z 这 26 个小写字符，我们**用二十六进制来表示一个字符串，对应的哈希值就是二十六进制数转化成十进制**的结果。

&emsp;这种哈希算法有一个特点，**在主串中，相邻两个子串的哈希值的计算公式有一定关系**

![](https://i.loli.net/2020/10/21/zTs7doHbZXvFDCG.jpg)

&emsp;得出这样的规律：相邻两个子串 s[i-1]和 s[i]（i 表示子串在主串中的起始位置，子串的长度都为 m），对应的哈希值计算公式有交集，也就是说，我们可以使用 s[i-1]的哈希值很快的计算出 s[i]的哈希值。

![](https://i.loli.net/2020/10/21/hnoRJ9mOtDPYcUL.jpg)

&emsp;有一个小细节需要注意，我们事先计算好 26^0、26^1、26^2……26^(m-1)，并且存储在一个长度为 m 的数组中，公式中的“次方”就对应数组的下标。当我们需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间。

![](https://i.loli.net/2020/10/21/i48oGAPh7Fmjr5d.jpg)

&emsp;我们前面也分析了，可以通过设计特殊的哈希算法，**只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 O(n)。**

&emsp;模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 O(1)，总共**需要比较 n-m+1 个子串的哈希值**，所以，这部分的时间复杂度也是 O(n)。所以，**RK 算法整体的时间复杂度就是 O(n)**。

&emsp;模式串很长，相应的主串中的子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，如果超过了计算机中整型数据可以表示的范围，那该如何解决呢？

&emsp;假设字符串中只包含 a～z 这 26 个英文字母，那我们每个字母对应一个数字，比如 a 对应 1，b 对应 2，以此类推，z 对应 26。**我们可以把字符串中每个字母对应的数字相加，最后得到的和作为哈希值。这种哈希算法产生的哈希值的数据范围就相对要小很多了。**

&emsp;还有很多更加优化的方法，比如**将每一个字母从小到大对应一个素数，而不是 1，2，3……这样的自然数，这样冲突的概率就会降低一些。**

&emsp;当存在哈希冲突的时候，有可能存在这样的情况，**子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配**。

&emsp;当我们**发现一个子串的哈希值跟模式串的哈希值相等的时候，我们只需要再对比一下子串和模式串本身**就好了。当然，如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身了。



### 解答开篇

>RK 算法是如何借助哈希算法来实现高效字符串匹配的呢

&emsp;即**对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间**。所以，理想情况下，**RK 算法的时间复杂度是 O(n)**，极端情况下，**哈希算法大量冲突，时间复杂度就退化为 O(n*m)**。



### 课后思考

> 假设有下面这样一个二维字符串矩阵（图中的主串），借助今天讲的处理思路，如何在其中查找另一个二维字符串矩阵（图中的模式串）呢？

![](https://i.loli.net/2020/10/21/j1XaAKBpz9OyHcV.jpg)

